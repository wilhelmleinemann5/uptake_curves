<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Departure Canary Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <link rel="stylesheet" href="styles/maersk-theme.css">
    <style>
        .container { max-width: 1600px; }

        /* Dashboard grid */
        .departure-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.25rem;
            margin: 1.5rem 0;
        }
        @media (max-width: 1024px) { .departure-grid { grid-template-columns: 1fr; } }

        .departure-panel {
            background: var(--mds-bg-secondary);
            border-radius: 10px;
            padding: 1rem 1.25rem;
            border: 1px solid var(--mds-border-default);
            position: relative;
            transition: box-shadow 0.2s;
        }
        .departure-panel:hover { box-shadow: 0 4px 16px rgba(0, 143, 211, 0.15); }

        .departure-panel .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        .departure-panel .vessel-name { font-weight: 700; font-size: 1rem; color: var(--mds-text-primary); }
        .departure-panel .route-tag { font-size: 0.7rem; padding: 3px 8px; border-radius: 4px; font-weight: 600; background: var(--mds-bg-tertiary); color: var(--mds-text-secondary); }

        .kpi-row { display: flex; gap: 0.5rem; margin-bottom: 0.75rem; flex-wrap: wrap; }
        .kpi-chip { background: var(--mds-bg-tertiary); padding: 4px 10px; border-radius: 4px; font-size: 0.75rem; white-space: nowrap; }
        .kpi-chip .kpi-label { color: var(--mds-text-weak); }
        .kpi-chip .kpi-value { color: var(--mds-text-primary); font-weight: 600; margin-left: 4px; }

        .canary-badge { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 4px; font-size: 0.75rem; font-weight: 700; }
        .canary-badge.green  { background: rgba(0,170,136,0.15); color: var(--maersk-success); }
        .canary-badge.yellow { background: rgba(255,165,0,0.15); color: var(--maersk-warning); }
        .canary-badge.red    { background: rgba(229,62,62,0.15); color: var(--maersk-error); }

        /* Spike detector table */
        .spike-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        .spike-table th { text-align: left; padding: 6px 10px; color: var(--mds-text-secondary); border-bottom: 1px solid var(--mds-border-default); font-weight: 600; }
        .spike-table td { padding: 6px 10px; color: var(--mds-text-primary); border-bottom: 1px solid rgba(76,76,76,0.4); cursor: pointer; }
        .spike-table tr:hover td { background: rgba(0,143,211,0.08); }
        .spike-table tr.active td { background: rgba(0,143,211,0.18); }

        /* Controls bar */
        .controls-bar { display: flex; gap: 1rem; align-items: center; flex-wrap: wrap; background: var(--mds-bg-secondary); padding: 0.75rem 1rem; border-radius: 8px; border: 1px solid var(--mds-border-default); }
        .controls-bar label { color: var(--mds-text-secondary); font-size: 0.85rem; font-weight: 500; }
        .controls-bar select, .controls-bar input[type="number"] { background: var(--mds-bg-tertiary); color: var(--mds-text-primary); border: 1px solid var(--mds-border-default); border-radius: 4px; padding: 6px 10px; font-size: 0.85rem; }

        /* Global canary summary */
        .global-canary { display: flex; align-items: center; gap: 1rem; padding: 0.75rem 1.25rem; border-radius: 8px; border: 2px solid var(--maersk-blue); background: var(--mds-bg-secondary); }
        .global-canary .gc-icon { font-size: 1.6rem; }
        .global-canary .gc-label { font-size: 0.85rem; color: var(--mds-text-secondary); }
        .global-canary .gc-value { font-size: 1.6rem; font-weight: 700; }

        /* Cross-highlight date label */
        .cross-date-label { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: var(--maersk-blue); color: white; padding: 8px 20px; border-radius: 20px; font-weight: 600; font-size: 0.85rem; z-index: 5000; display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.4); pointer-events: none; }

        /* Aggregated metrics bar */
        .agg-metrics { display: none; gap: 1rem; padding: 0.6rem 1rem; border-radius: 6px; background: var(--mds-bg-tertiary); font-size: 0.8rem; color: var(--mds-text-secondary); flex-wrap: wrap; }
        .agg-metrics .agg-val { color: var(--mds-text-primary); font-weight: 700; }

        /* View tabs */
        .view-tabs { display: flex; gap: 0; margin: 1.5rem 0 0 0; border-bottom: 2px solid var(--mds-border-default); }
        .view-tab {
            padding: 10px 24px; font-size: 0.9rem; font-weight: 600; cursor: pointer;
            color: var(--mds-text-secondary); background: none; border: none;
            border-bottom: 3px solid transparent; margin-bottom: -2px; transition: all 0.2s;
        }
        .view-tab:hover { color: var(--mds-text-primary); }
        .view-tab.active { color: var(--maersk-blue); border-bottom-color: var(--maersk-blue); }
        .view-section { display: none; }
        .view-section.active { display: block; }

        /* Full-width chart panels */
        .full-chart-panel {
            background: var(--mds-bg-secondary); border-radius: 10px; padding: 1.25rem;
            border: 1px solid var(--mds-border-default); margin: 1.5rem 0;
        }
        .full-chart-panel h3 { color: var(--mds-text-primary); margin: 0 0 1rem 0; font-size: 1.1rem; }

        /* DTD bucket colors */
        .bucket-legend { display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem; font-size: 0.8rem; }
        .bucket-legend-item { display: flex; align-items: center; gap: 5px; }
        .bucket-swatch { width: 14px; height: 14px; border-radius: 3px; }
    </style>
</head>
<body>
    <header class="header">
        <h1>ğŸš¢ Multi-Departure Canary Dashboard</h1>
        <p>Cross-Departure Booking Velocity Monitoring &amp; Anomaly Detection</p>
    </header>

    <div class="container">
        <div class="demo-note">
            <h3>ğŸ“¡ Live Multi-Departure View</h3>
            <p>Monitor multiple departures simultaneously. Detect slope deviations across uptake curves, analyse DTD-bucket time series, and surface aggregate demand spikes.</p>
        </div>

        <!-- Controls Bar -->
        <div class="controls-bar" style="margin: 1.5rem 0;">
            <button onclick="document.getElementById('helpModal').style.display='flex'" style="background:none;border:1px solid var(--mds-border-default);color:var(--mds-text-secondary);padding:6px 12px;border-radius:4px;cursor:pointer;font-size:0.85rem;" title="Help & Glossary">â“ Help</button>
            <div>
                <label for="aggregationLevel">ğŸ“Š Aggregation:</label>
                <select id="aggregationLevel" onchange="updateAggregation()">
                    <option value="departure" selected>Departure Level</option>
                    <option value="route">Route Level</option>
                    <option value="trade">Trade Level</option>
                </select>
            </div>
            <div>
                <label for="spikeThreshold">ğŸ¯ Spike CDF:</label>
                <input type="number" id="spikeThreshold" value="0.95" min="0.80" max="0.99" step="0.01" style="width: 75px;" onchange="onControlChange()" oninput="onControlChange()">
            </div>
            <div>
                <label for="slopeThresholdSigma">ğŸ“ Slope Ïƒ:</label>
                <input type="number" id="slopeThresholdSigma" value="1.5" min="0.5" max="4.0" step="0.25" style="width: 65px;" title="Flag slopes exceeding this many standard deviations" onchange="onControlChange()" oninput="onControlChange()">
            </div>
            <div>
                <label for="bucketSize">ğŸ“… Bucket (days):</label>
                <select id="bucketSize" onchange="onControlChange()">
                    <option value="7" selected>7</option>
                    <option value="14">14</option>
                    <option value="5">5</option>
                </select>
            </div>
            <div style="flex: 1;"></div>
            <button onclick="generateAll()" style="background: var(--maersk-blue); color: white; border: none; padding: 8px 20px; border-radius: 6px; font-weight: 600; cursor: pointer;">
                ğŸ”„ Generate / Refresh
            </button>
        </div>

        <!-- Global Canary Summary -->
        <div style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;">
            <div class="global-canary" style="flex: 1; min-width: 220px;">
                <div class="gc-icon">ğŸ¦</div>
                <div><div class="gc-label">Global Canary Signal</div><div class="gc-value" id="globalCanaryValue" style="color: var(--maersk-blue);">â€”</div></div>
            </div>
            <div class="global-canary" style="flex: 1; min-width: 220px;">
                <div class="gc-icon">ğŸ“ˆ</div>
                <div><div class="gc-label">Total Bookings</div><div class="gc-value" id="globalTotalBookings" style="color: var(--maersk-success);">â€”</div></div>
            </div>
            <div class="global-canary" style="flex: 1; min-width: 220px;">
                <div class="gc-icon">ğŸ“</div>
                <div><div class="gc-label">Slope Anomalies</div><div class="gc-value" id="globalSlopeSpikes" style="color: var(--maersk-warning);">â€”</div></div>
            </div>
            <div class="global-canary" style="flex: 1; min-width: 220px;">
                <div class="gc-icon">âš¡</div>
                <div><div class="gc-label">CDF Anomalies</div><div class="gc-value" id="globalActiveSpikes" style="color: var(--maersk-error);">â€”</div></div>
            </div>
        </div>

        <!-- Aggregated Metrics (shown on hover) -->
        <div class="agg-metrics" id="aggMetrics">
            <span>ğŸ“… <span class="agg-val" id="aggDate">â€”</span></span>
            <span>ğŸ“¦ Total: <span class="agg-val" id="aggBookings">â€”</span></span>
            <span>ğŸ“ Avg Slope: <span class="agg-val" id="aggSlope">â€”</span></span>
            <span>ğŸ“Š Avg Z: <span class="agg-val" id="aggZScore">â€”</span></span>
            <span>ğŸ¦ Avg CDF: <span class="agg-val" id="aggCDF">â€”</span></span>
            <span>ğŸš¨ Spikes: <span class="agg-val" id="aggSpikeCount">â€”</span></span>
        </div>

        <!-- View Tabs -->
        <div class="view-tabs">
            <button class="view-tab active" onclick="switchView('departures')">ğŸš¢ Departures</button>
            <button class="view-tab" onclick="switchView('timeseries')">ğŸ“ˆ DTD-Bucket Series</button>
            <button class="view-tab" onclick="switchView('aggregate')">ğŸ“Š Aggregate</button>
        </div>

        <!-- VIEW 1: Departure Panels -->
        <div class="view-section active" id="view-departures">
            <div class="departure-grid" id="departureGrid"></div>
        </div>

        <!-- VIEW 2: DTD-Bucket Time Series -->
        <div class="view-section" id="view-timeseries">
            <div class="full-chart-panel">
                <h3>ğŸ“ˆ Booking Volume by DTD Bucket â€” Time Series with Confidence Bands</h3>
                <p style="color: var(--mds-text-weak); font-size: 0.8rem; margin-bottom: 1rem;">Each line represents total daily bookings across all departures for a specific DTD bucket. Shaded bands show Â±2Ïƒ confidence interval. Red dots mark anomalies.</p>
                <div id="bucketLegend" class="bucket-legend"></div>
                <div style="position: relative; height: 400px;"><canvas id="timeseriesChart"></canvas></div>
            </div>
        </div>

        <!-- VIEW 3: Aggregate Stacked -->
        <div class="view-section" id="view-aggregate">
            <div class="full-chart-panel">
                <h3>ğŸ“Š Aggregate Bookings by Booking Date â€” Stacked by DTD Bucket</h3>
                <p style="color: var(--mds-text-weak); font-size: 0.8rem; margin-bottom: 1rem;">Total bookings across all departures, coloured by DTD bucket. Anomalous dates are circled. This view surfaces collective spikes that no single curve would reveal.</p>
                <div id="aggBucketLegend" class="bucket-legend"></div>
                <div style="position: relative; height: 400px;"><canvas id="aggregateChart"></canvas></div>
            </div>
            <div class="full-chart-panel">
                <h3>ğŸ”¬ Aggregate Anomaly Score â€” Z-Score by Booking Date</h3>
                <p style="color: var(--mds-text-weak); font-size: 0.8rem; margin-bottom: 1rem;">Combined z-score across all departures. Horizontal lines mark Â±2Ïƒ threshold.</p>
                <div style="position: relative; height: 220px;"><canvas id="aggZScoreChart"></canvas></div>
            </div>
        </div>

        <!-- Spike Detector Panel -->
        <div style="background: var(--mds-bg-secondary); border-radius: 10px; padding: 1.25rem; border: 1px solid var(--mds-border-default); margin: 1.5rem 0;">
            <h3 style="color: var(--mds-text-primary); margin: 0 0 1rem 0; font-size: 1.1rem;">ğŸš¨ Spike Detector â€” High-Anomaly Booking Days</h3>
            <div style="max-height: 300px; overflow-y: auto;">
                <table class="spike-table" id="spikeTable">
                    <thead><tr><th>Date</th><th>Total FFE</th><th>Avg Z-Score</th><th>Avg CDF</th><th>Slope Flags</th><th>Departures</th><th>Signal</th></tr></thead>
                    <tbody id="spikeTableBody">
                        <tr><td colspan="7" style="text-align: center; color: var(--mds-text-weak); padding: 2rem;">Click "Generate / Refresh" to simulate.</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Navigation -->
        <div style="text-align: center; margin: 2rem 0;">
            <a href="live-pricing-advanced-simulator.html" style="display: inline-block; background: var(--mds-bg-strong); color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-weight: 500; margin-right: 1rem;">ğŸ® Single-Departure Simulator</a>
            <a href="live-pricing-simple.html" style="display: inline-block; background: var(--mds-bg-strong); color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-weight: 500; margin-right: 1rem;">ğŸ“Š Simple Simulator</a>
            <a href="index.html" style="display: inline-block; background: var(--mds-bg-strong); color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-weight: 500;">ğŸ“ˆ Historical Analysis</a>
        </div>
    </div>

    <div class="cross-date-label" id="crossDateLabel">â€”</div>

    <!-- Help Modal -->
    <div id="helpModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:10000; justify-content:center; align-items:center;">
        <div style="background:var(--mds-bg-primary,#1a1a1a); border-radius:12px; padding:2rem; max-width:650px; width:90%; max-height:80vh; overflow-y:auto; box-shadow:0 8px 32px rgba(0,0,0,0.5);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1.5rem;">
                <h2 style="color:var(--maersk-blue); margin:0;">ğŸ“– Dashboard Glossary</h2>
                <button onclick="document.getElementById('helpModal').style.display='none'" style="background:none;border:none;color:var(--mds-text-secondary);font-size:1.5rem;cursor:pointer;">Ã—</button>
            </div>
            <div style="color:var(--mds-text-secondary); font-size:0.9rem; line-height:1.7;">
                <h3 style="color:var(--mds-text-primary); margin:1rem 0 0.5rem;">Key Metrics</h3>
                <p><strong style="color:var(--maersk-blue);">FFE (Forty-Foot Equivalent)</strong> â€” Standard unit for container bookings. The uptake curve plots cumulative FFE booked vs days-to-departure (DTD).</p>
                <p><strong style="color:var(--maersk-blue);">DTD (Days to Departure)</strong> â€” Time remaining before the vessel departs. Bookings typically ramp up as DTD decreases (approaching departure).</p>
                <p><strong style="color:var(--maersk-blue);">Slope</strong> â€” The daily change in cumulative bookings (Î” FFE/day). A sudden increase in slope indicates accelerating demand; a drop indicates slowing demand.</p>
                <h3 style="color:var(--mds-text-primary); margin:1rem 0 0.5rem;">Anomaly Detection</h3>
                <p><strong style="color:var(--maersk-warning);">Z-Score</strong> â€” Measures how many standard deviations a data point is from the rolling mean. Values beyond Â±2 are unusual.</p>
                <p><strong style="color:var(--maersk-warning);">CDF (Cumulative Distribution Function)</strong> â€” The percentile ranking derived from the z-score. CDF &gt; 0.95 means the value is in the top 5% (unusually high); CDF &lt; 0.05 means bottom 5% (unusually low).</p>
                <p><strong style="color:var(--maersk-error);">Slope Ïƒ (Sigma)</strong> â€” The threshold for flagging slope deviations. A slope deviation of &gt;1.5Ïƒ from the expected slope at that DTD triggers a red marker on the chart. Lower values = more sensitive.</p>
                <h3 style="color:var(--mds-text-primary); margin:1rem 0 0.5rem;">Views</h3>
                <p><strong>ğŸš¢ Departures</strong> â€” Individual uptake curves per vessel. Red circles (â—) mark slope anomalies. Hover for slope, expected slope, and deviation details.</p>
                <p><strong>ğŸ“ˆ DTD-Bucket Series</strong> â€” Bookings aggregated into DTD buckets (e.g. 0-6 days, 7-13 days) and plotted by booking date. Shaded bands show normal range (Â±2Ïƒ). Red dots mark anomalies.</p>
                <p><strong>ğŸ“Š Aggregate</strong> â€” Total bookings stacked by DTD bucket. Surfaces collective spikes that no single curve would reveal. The z-score bar chart below shows the combined anomaly score.</p>
                <h3 style="color:var(--mds-text-primary); margin:1rem 0 0.5rem;">Controls</h3>
                <p><strong>Spike CDF</strong> â€” Threshold for CDF-based anomalies (default 0.95). Values above this or below (1 âˆ’ threshold) are flagged.</p>
                <p><strong>Slope Ïƒ</strong> â€” Threshold for slope-based anomalies (default 1.5). Lower = more flags.</p>
                <p><strong>Bucket (days)</strong> â€” Size of DTD buckets for the time-series and aggregate views.</p>
                <p><strong>Aggregation</strong> â€” Group departures by individual vessel, route, or trade lane.</p>
            </div>
            <div style="text-align:right; margin-top:1.5rem;">
                <button onclick="document.getElementById('helpModal').style.display='none'" style="background:var(--maersk-blue);color:white;border:none;border-radius:6px;padding:0.6rem 1.5rem;font-weight:600;cursor:pointer;">Close</button>
            </div>
        </div>
    </div>

    <script>
    // ============================================================
    // CONFIGURATION
    // ============================================================
    const DEPARTURES = [
        { id:'dep-1', vesselName:'Maersk Emerald',  route:'SHA â†’ RTM', trade:'Asia-Europe',   departureDate:'2025-06-30', capacity:220, marketPrice:3100, channelPrice:3200, openDTD:35, baseVolume:550, color:'rgb(0, 143, 211)' },
        { id:'dep-2', vesselName:'Maersk Sapphire', route:'NGB â†’ FEL', trade:'Asia-Europe',   departureDate:'2025-07-07', capacity:180, marketPrice:2800, channelPrice:2890, openDTD:30, baseVolume:480, color:'rgb(0, 170, 136)' },
        { id:'dep-3', vesselName:'Maersk Horizon',  route:'YTN â†’ LAX', trade:'Transpacific',  departureDate:'2025-07-14', capacity:250, marketPrice:3500, channelPrice:3600, openDTD:32, baseVolume:600, color:'rgb(255, 165, 0)' },
        { id:'dep-4', vesselName:'Maersk Atlas',    route:'QIN â†’ NYC', trade:'Transpacific',  departureDate:'2025-07-21', capacity:200, marketPrice:3200, channelPrice:3300, openDTD:28, baseVolume:520, color:'rgb(176, 130, 255)' }
    ];

    const SIM_CONFIG = {
        horizonDays: 49, offersPerSearch: 1.0, elasticity: 1.25, bookingConversion: 0.03,
        weekendMultiplier: 0.20, rampStart: 28, taperStart: 5, cancellationFee: 250,
        feePassThrough: 0.15, cancelCap: 0.05, noCancelInside: 5,
        marketVolatility: 0.03, searchVolatility: 0.10, shockProbability: 0.12
    };

    const BUCKET_COLORS = [
        'rgb(0, 143, 211)',   // 0-6   Maersk blue
        'rgb(0, 170, 136)',   // 7-13  Teal
        'rgb(255, 215, 0)',   // 14-20 Gold
        'rgb(255, 165, 0)',   // 21-27 Orange
        'rgb(229, 62, 62)',   // 28-34 Red
        'rgb(176, 130, 255)', // 35-41 Purple
        'rgb(138, 138, 138)'  // 42-49 Grey
    ];

    // ============================================================
    // STATE
    // ============================================================
    let departureDataSets = {};
    let spikeData = [];
    let chartInstances = {};
    let currentHighlightDate = null;
    let bucketData = {};       // { bucketLabel -> { dates[], values[], forecast[], upper[], lower[], zScores[], cdfValues[] } }
    let aggregateByDate = {};  // { dateStr -> { buckets: { label->value }, total, avgZ, avgCDF } }

    // ============================================================
    // CORE SIMULATION (unchanged)
    // ============================================================
    function dtdBellCurve(dtd, baseVol, kRamp=0.18, kTaper=0.35, rampStart=28, taperStart=5) {
        const D = Math.max(parseInt(dtd), 0);
        return baseVol / (1+Math.exp(-kRamp*(rampStart-D))) / (1+Math.exp(-kTaper*(D-taperStart)));
    }

    function makeRNG(seed) { let s=seed; return function(){ s=(s*9301+49297)%233280; return s/233280; }; }

    function generateDepartureData(config) {
        const rng = makeRNG(hashString(config.id + config.departureDate));
        const depDate = new Date(config.departureDate);
        const records = [];
        let cumFFE=0, cumRev=0, cumCxlFFE=0, currentMP=config.marketPrice;

        for (let dtd = SIM_CONFIG.horizonDays; dtd >= 0; dtd--) {
            const bookingDate = new Date(depDate); bookingDate.setDate(bookingDate.getDate() - dtd);
            const dow = bookingDate.getDay();
            const isWeekend = dow===0||dow===6;
            const dowMult = isWeekend ? SIM_CONFIG.weekendMultiplier : 1.0;
            const isOpen = dtd <= config.openDTD;

            if (dtd < SIM_CONFIG.horizonDays) currentMP *= (1 + (rng()-0.5)*2*SIM_CONFIG.marketVolatility);

            let shockApplied=false, shockDirection=null, shockMagnitude=0;
            if (rng() < SIM_CONFIG.shockProbability) {
                shockApplied=true; shockDirection = rng()<0.5?'upward':'downward';
                shockMagnitude = 5 + rng()*5;
                currentMP *= shockDirection==='upward' ? (1+shockMagnitude/100) : (1-shockMagnitude/100);
            }

            const cp = config.channelPrice;
            const cpEff = cp + SIM_CONFIG.feePassThrough * SIM_CONFIG.cancellationFee;
            const pricingRatio = cpEff / currentMP;
            const weekdayMean = dtdBellCurve(dtd, config.baseVolume);
            const meanSearches = Math.max(0, weekdayMean * dowMult);
            const searches = Math.max(0, Math.round(meanSearches * (1 + (rng()-0.5)*2*SIM_CONFIG.searchVolatility)));
            const remainingCapacity = Math.max(config.capacity - cumFFE, 0);

            let bookedFFE=0, revenue=0, offers=0, adjConversion=0;
            if (isOpen && remainingCapacity > 0) {
                offers = Math.round(SIM_CONFIG.offersPerSearch * searches);
                adjConversion = SIM_CONFIG.bookingConversion * Math.pow(pricingRatio, -SIM_CONFIG.elasticity);
                bookedFFE = Math.min(offers * Math.max(adjConversion,0), remainingCapacity);
                revenue = (currentMP * pricingRatio) * bookedFFE;
            }

            const cumFFEPre = cumFFE + bookedFFE;
            const cumRevPre = cumRev + revenue;
            let cxlFFE=0, cxlRev=0;
            if (dtd >= SIM_CONFIG.noCancelInside && cumFFEPre > 0) {
                const bookedPrice = cumRevPre / Math.max(cumFFEPre, 1e-9);
                const cancelVal = bookedPrice - Math.min(currentMP, cp) - SIM_CONFIG.cancellationFee;
                if (cancelVal > 0) {
                    const baseRate = 1 - Math.exp(-cancelVal / Math.max(SIM_CONFIG.cancellationFee, 1e-9));
                    cxlFFE = Math.min(cumFFEPre * Math.min(SIM_CONFIG.cancelCap, baseRate*SIM_CONFIG.cancelCap), cumFFEPre);
                    cxlRev = cxlFFE * SIM_CONFIG.cancellationFee;
                }
            }
            const cancelledBookingRev = cxlFFE > 0 ? (cxlFFE/Math.max(cumFFEPre,1e-9))*cumRevPre : 0;
            cumFFE = cumFFEPre - cxlFFE;
            cumRev = (cumRevPre - cancelledBookingRev) + cxlRev;
            cumCxlFFE += cxlFFE;

            records.push({
                bookingDate: new Date(bookingDate), dtd, isOpen, searches, offers,
                bookedFFE, cumFFE, revenue, cumRev, cxlFFE, cumCxlFFE,
                remainingCapacity: Math.max(config.capacity-cumFFE,0),
                marketPrice: currentMP, channelPrice: cp, pricingRatio,
                shockApplied, shockDirection, shockMagnitude
            });
        }
        return records;
    }

    function hashString(str) { let h=0; for(let i=0;i<str.length;i++){h=((h<<5)-h)+str.charCodeAt(i);h|=0;} return Math.abs(h); }

    // ============================================================
    // Z-SCORE / CDF
    // ============================================================
    function computeZScores(dailyData, windowSize=7) {
        const vals = dailyData.map(d=>d.bookedFFE);
        const zScores=[], cdfValues=[];
        for (let i=0; i<vals.length; i++) {
            const start = Math.max(0, i-windowSize+1);
            const w = vals.slice(start, i+1);
            if (w.length<3) { zScores.push(0); cdfValues.push(0.5); continue; }
            const mean = w.reduce((a,b)=>a+b,0)/w.length;
            const std = Math.sqrt(w.reduce((a,b)=>a+(b-mean)**2,0)/w.length);
            const z = std>0.01 ? (vals[i]-mean)/std : 0;
            zScores.push(z); cdfValues.push(normalCDF(z));
        }
        return {zScores, cdfValues};
    }

    function normalCDF(x) {
        const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;
        const sign=x<0?-1:1, t=1/(1+p*Math.abs(x));
        return 0.5*(1+sign*(1-(((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t*Math.exp(-x*x/2)));
    }

    // ============================================================
    // SLOPE COMPUTATION & SPIKE DETECTION
    // ============================================================

    /** Compute daily slope (Î” cumFFE / day) for a departure */
    function computeSlopes(dailyData) {
        const slopes = [];
        for (let i=0; i<dailyData.length; i++) {
            if (i === 0) { slopes.push(dailyData[i].bookedFFE); }
            else { slopes.push(dailyData[i].cumFFE - dailyData[i-1].cumFFE); }
        }
        return slopes;
    }

    /**
     * Compute expected slope at each DTD using rolling window within each departure.
     * This avoids the small-sample problem of cross-departure comparison (only 4 departures).
     * We combine: (a) a smoothed bell-curve expectation, and (b) cross-departure pooling
     * of windowed residuals to get a robust std estimate.
     */
    function computeTypicalSlopes() {
        // Pool all slopes by DTD across departures for the mean
        const slopesByDTD = {};
        Object.values(departureDataSets).forEach(ds => {
            ds.slopes.forEach((s, i) => {
                const dtd = ds.dailyData[i].dtd;
                if (!slopesByDTD[dtd]) slopesByDTD[dtd] = [];
                slopesByDTD[dtd].push(s);
            });
        });

        const typicalSlope = {};
        Object.entries(slopesByDTD).forEach(([dtd, values]) => {
            typicalSlope[dtd] = values.reduce((a,b)=>a+b,0) / values.length;
        });

        // Compute std using rolling window of residuals across ALL departures pooled.
        // For each departure, compute residual (slope - typicalSlope) at each DTD,
        // then use a Â±3 DTD window to estimate local variability.
        const residualsByDTD = {};
        Object.values(departureDataSets).forEach(ds => {
            ds.slopes.forEach((s, i) => {
                const dtd = ds.dailyData[i].dtd;
                const residual = s - (typicalSlope[dtd] || 0);
                if (!residualsByDTD[dtd]) residualsByDTD[dtd] = [];
                residualsByDTD[dtd].push(residual);
            });
        });

        const typicalStd = {};
        const allDTDs = Object.keys(residualsByDTD).map(Number).sort((a,b) => a-b);
        allDTDs.forEach(dtd => {
            // Pool residuals from nearby DTDs (Â±3) for more robust std
            let pooled = [];
            allDTDs.forEach(d => {
                if (Math.abs(d - dtd) <= 3) {
                    pooled = pooled.concat(residualsByDTD[d] || []);
                }
            });
            if (pooled.length < 2) { typicalStd[dtd] = 0.1; return; }
            const mean = pooled.reduce((a,b)=>a+b,0) / pooled.length;
            typicalStd[dtd] = Math.sqrt(pooled.reduce((a,b)=>a+(b-mean)**2,0) / pooled.length);
        });

        return { typicalSlope, typicalStd };
    }

    /** Flag slope anomalies per departure using robust cross-departure baseline */
    function detectSlopeSpikes() {
        const sigmaThreshold = parseFloat(document.getElementById('slopeThresholdSigma').value) || 1.5;
        const { typicalSlope, typicalStd } = computeTypicalSlopes();

        let totalSlopeSpikes = 0;

        Object.values(departureDataSets).forEach(ds => {
            ds.slopeSpikes = [];
            ds.slopes.forEach((s, i) => {
                const dtd = ds.dailyData[i].dtd;
                const expected = typicalSlope[dtd] || 0;
                const std = typicalStd[dtd] || 0.1;
                // Use max of local std and a minimum floor to avoid false positives on near-zero slopes
                const effectiveStd = Math.max(std, 0.05);
                const deviation = Math.abs(s - expected) / effectiveStd;
                const isSpike = deviation > sigmaThreshold && Math.abs(s - expected) > 0.1; // also require meaningful absolute diff
                ds.slopeSpikes.push({
                    slope: s, expected, std: effectiveStd, deviation, isSpike,
                    direction: s > expected ? 'above' : 'below'
                });
                if (isSpike) totalSlopeSpikes++;
            });
        });

        document.getElementById('globalSlopeSpikes').textContent = totalSlopeSpikes;
    }

    // ============================================================
    // DTD-BUCKET TIME SERIES
    // ============================================================

    function getBucketDefs() {
        const size = parseInt(document.getElementById('bucketSize').value) || 7;
        const buckets = [];
        for (let start = 0; start <= SIM_CONFIG.horizonDays; start += size) {
            const end = Math.min(start + size - 1, SIM_CONFIG.horizonDays);
            buckets.push({ label: `${start}-${end} DTD`, start, end });
        }
        return buckets;
    }

    function buildDTDBuckets() {
        const bucketDefs = getBucketDefs();
        bucketData = {};
        aggregateByDate = {};

        // Collect all booking dates
        const allDates = new Set();
        Object.values(departureDataSets).forEach(ds => {
            ds.dailyData.forEach(d => allDates.add(d.bookingDate.toISOString().split('T')[0]));
        });
        const sortedDates = [...allDates].sort();

        // Initialize buckets
        bucketDefs.forEach(b => {
            bucketData[b.label] = { dates: sortedDates, values: [], def: b, colorIdx: bucketDefs.indexOf(b) };
        });
        sortedDates.forEach(date => {
            aggregateByDate[date] = { buckets: {}, total: 0, zScores: [], cdfValues: [], slopeFlags: 0 };
            bucketDefs.forEach(b => { aggregateByDate[date].buckets[b.label] = 0; });
        });

        // Fill buckets
        Object.values(departureDataSets).forEach(ds => {
            ds.dailyData.forEach((d, i) => {
                const dateStr = d.bookingDate.toISOString().split('T')[0];
                const dtd = d.dtd;
                const bucket = bucketDefs.find(b => dtd >= b.start && dtd <= b.end);
                if (bucket && aggregateByDate[dateStr]) {
                    aggregateByDate[dateStr].buckets[bucket.label] += d.bookedFFE;
                    aggregateByDate[dateStr].total += d.bookedFFE;
                    aggregateByDate[dateStr].zScores.push(ds.zScores[i] || 0);
                    aggregateByDate[dateStr].cdfValues.push(ds.cdfValues[i] || 0.5);
                    if (ds.slopeSpikes && ds.slopeSpikes[i] && ds.slopeSpikes[i].isSpike) {
                        aggregateByDate[dateStr].slopeFlags++;
                    }
                }
            });
        });

        // Build per-bucket value arrays and compute forecasts
        const bucketLabels = bucketDefs.map(b => b.label);
        bucketLabels.forEach(label => {
            const values = sortedDates.map(d => aggregateByDate[d].buckets[label] || 0);
            bucketData[label].values = values;

            // Moving average forecast + confidence band
            const windowSize = 5;
            const forecast = [], upper = [], lower = [], zScores = [], cdfValues = [];
            for (let i = 0; i < values.length; i++) {
                const start = Math.max(0, i - windowSize + 1);
                const window = values.slice(start, i + 1);
                const mean = window.reduce((a,b)=>a+b,0)/window.length;
                const std = Math.sqrt(window.reduce((a,b)=>a+(b-mean)**2,0)/window.length);
                forecast.push(mean);
                upper.push(mean + 2 * std);
                lower.push(Math.max(0, mean - 2 * std));
                const z = std > 0.01 ? (values[i] - mean) / std : 0;
                zScores.push(z);
                cdfValues.push(normalCDF(z));
            }
            bucketData[label].forecast = forecast;
            bucketData[label].upper = upper;
            bucketData[label].lower = lower;
            bucketData[label].zScores = zScores;
            bucketData[label].cdfValues = cdfValues;
        });
    }

    // ============================================================
    // SPIKE DETECTION (enhanced with slope flags)
    // ============================================================

    function detectSpikes() {
        const threshold = parseFloat(document.getElementById('spikeThreshold').value) || 0.95;
        const lowThreshold = 1 - threshold;
        const dateMap = {};

        Object.values(departureDataSets).forEach(ds => {
            ds.dailyData.forEach((d, i) => {
                const key = d.bookingDate.toISOString().split('T')[0];
                if (!dateMap[key]) dateMap[key] = { date:key, totalFFE:0, zScores:[], cdfValues:[], deps:[], slopeFlags:0 };
                dateMap[key].totalFFE += d.bookedFFE;
                dateMap[key].zScores.push(ds.zScores[i]||0);
                dateMap[key].cdfValues.push(ds.cdfValues[i]||0.5);
                if (ds.slopeSpikes && ds.slopeSpikes[i] && ds.slopeSpikes[i].isSpike) {
                    dateMap[key].slopeFlags++;
                    dateMap[key].deps.push(ds.config.vesselName);
                }
                if (ds.cdfValues[i] > threshold || ds.cdfValues[i] < lowThreshold) {
                    dateMap[key].deps.push(ds.config.vesselName);
                }
            });
        });

        spikeData = Object.values(dateMap)
            .map(e => {
                const avgZ = e.zScores.reduce((a,b)=>a+b,0)/e.zScores.length;
                const avgCDF = e.cdfValues.reduce((a,b)=>a+b,0)/e.cdfValues.length;
                return { date:e.date, totalFFE:e.totalFFE, avgZScore:avgZ, avgCDF:avgCDF,
                    affectedDeps:[...new Set(e.deps)], slopeFlags:e.slopeFlags,
                    isSpike: avgCDF > threshold || avgCDF < lowThreshold || e.slopeFlags >= 2 };
            })
            .filter(s => s.isSpike)
            .sort((a,b) => Math.abs(b.avgZScore) - Math.abs(a.avgZScore));

        renderSpikeTable();
        document.getElementById('globalActiveSpikes').textContent = spikeData.length;
    }

    function renderSpikeTable() {
        const tbody = document.getElementById('spikeTableBody');
        if (!spikeData.length) { tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;color:var(--mds-text-weak);padding:1.5rem;">No anomalous days detected.</td></tr>'; return; }
        tbody.innerHTML = spikeData.map(s => {
            const c = s.avgCDF > 0.5 ? 'var(--maersk-success)' : 'var(--maersk-error)';
            const icon = s.avgCDF > 0.5 ? 'ğŸ“ˆ' : 'ğŸ“‰';
            return `<tr onclick="highlightDate('${s.date}')">
                <td style="font-weight:600;">${s.date}</td>
                <td>${s.totalFFE.toFixed(1)}</td>
                <td style="color:${c};font-weight:600;">${s.avgZScore.toFixed(2)}</td>
                <td>${s.avgCDF.toFixed(3)}</td>
                <td style="color:${s.slopeFlags>=2?'var(--maersk-error)':'var(--mds-text-primary)'}; font-weight:600;">${s.slopeFlags}</td>
                <td style="font-size:0.75rem;">${s.affectedDeps.join(', ')||'â€”'}</td>
                <td style="font-size:1.1rem;">${icon}</td></tr>`;
        }).join('');
    }

    // ============================================================
    // GENERATE ALL
    // ============================================================

    function generateAll() {
        departureDataSets = {};
        DEPARTURES.forEach(config => {
            const dailyData = generateDepartureData(config);
            const { zScores, cdfValues } = computeZScores(dailyData);
            const slopes = computeSlopes(dailyData);
            const recentCDF = cdfValues.slice(-7);
            const canarySignal = recentCDF.reduce((a,b)=>a+b,0)/recentCDF.length;
            departureDataSets[config.id] = { config, dailyData, zScores, cdfValues, slopes, canarySignal, slopeSpikes:[] };
        });

        detectSlopeSpikes();
        buildDTDBuckets();
        renderDashboard();
        detectSpikes();
        updateGlobalIndicators();
        renderTimeseriesChart();
        renderAggregateCharts();
    }

    function onControlChange() {
        if (!Object.keys(departureDataSets).length) return;
        detectSlopeSpikes();
        buildDTDBuckets();
        renderDashboard();
        detectSpikes();
        updateGlobalIndicators();
        renderTimeseriesChart();
        renderAggregateCharts();
    }

    // ============================================================
    // RENDER DASHBOARD (departure panels with slope markers)
    // ============================================================

    function renderDashboard() {
        const grid = document.getElementById('departureGrid');
        const agg = document.getElementById('aggregationLevel').value;
        Object.entries(chartInstances).forEach(([k,c]) => { if(k.startsWith('dep-')||k.startsWith('agg-')) { c.destroy(); delete chartInstances[k]; } });
        grid.innerHTML = '';

        if (agg === 'departure') {
            Object.values(departureDataSets).forEach(ds => { grid.appendChild(createDeparturePanel(ds)); });
            Object.values(departureDataSets).forEach(ds => { createMiniChart(ds); });
        } else {
            const groups = {};
            Object.values(departureDataSets).forEach(ds => {
                const key = agg==='route' ? ds.config.route : ds.config.trade;
                if(!groups[key]) groups[key]=[]; groups[key].push(ds);
            });
            Object.entries(groups).forEach(([name, datasets]) => { grid.appendChild(createAggPanel(name, datasets, agg)); });
            Object.entries(groups).forEach(([name, datasets]) => { createAggGroupChart(name, datasets); });
        }
    }

    function createDeparturePanel(ds) {
        const {config, dailyData, canarySignal, slopeSpikes} = ds;
        const lastDay = dailyData[dailyData.length-1];
        const utilPct = ((lastDay.cumFFE/config.capacity)*100).toFixed(1);
        const canaryClass = canarySignal>0.7?'green':canarySignal>0.3?'yellow':'red';
        const slopeCount = slopeSpikes.filter(s=>s.isSpike).length;

        const panel = document.createElement('div');
        panel.className = 'departure-panel';
        panel.innerHTML = `
            <div class="panel-header">
                <div><span class="vessel-name">${config.vesselName}</span><span class="route-tag" style="margin-left:0.5rem;">${config.route}</span></div>
                <div style="display:flex;gap:0.5rem;align-items:center;">
                    ${slopeCount > 0 ? `<span style="background:rgba(229,62,62,0.15);color:var(--maersk-error);padding:3px 8px;border-radius:4px;font-size:0.7rem;font-weight:700;">ğŸ“ ${slopeCount} slope</span>` : ''}
                    <div class="canary-badge ${canaryClass}">ğŸ¦ ${canarySignal.toFixed(2)}</div>
                </div>
            </div>
            <div class="kpi-row">
                <div class="kpi-chip"><span class="kpi-label">Dep:</span><span class="kpi-value">${config.departureDate}</span></div>
                <div class="kpi-chip"><span class="kpi-label">FFE:</span><span class="kpi-value">${Math.round(lastDay.cumFFE)}/${config.capacity}</span></div>
                <div class="kpi-chip"><span class="kpi-label">Util:</span><span class="kpi-value">${utilPct}%</span></div>
                <div class="kpi-chip"><span class="kpi-label">Price:</span><span class="kpi-value">$${Math.round(lastDay.marketPrice)}</span></div>
            </div>
            <div style="position:relative;height:200px;"><canvas id="chart-${config.id}"></canvas></div>`;
        return panel;
    }

    function createAggPanel(name, datasets, groupKey) {
        const totalFFE = datasets.reduce((s,ds)=>s+ds.dailyData[ds.dailyData.length-1].cumFFE,0);
        const totalCap = datasets.reduce((s,ds)=>s+ds.config.capacity,0);
        const avgCanary = datasets.reduce((s,ds)=>s+ds.canarySignal,0)/datasets.length;
        const cClass = avgCanary>0.7?'green':avgCanary>0.3?'yellow':'red';
        const chartId = 'chart-agg-'+name.replace(/[^a-zA-Z0-9]/g,'');
        const panel = document.createElement('div');
        panel.className = 'departure-panel';
        panel.innerHTML = `
            <div class="panel-header">
                <div><span class="vessel-name">${groupKey==='trade'?'ğŸŒ ':'ğŸ”— '}${name}</span><span class="route-tag" style="margin-left:0.5rem;">${datasets.length} departures</span></div>
                <div class="canary-badge ${cClass}">ğŸ¦ ${avgCanary.toFixed(2)}</div>
            </div>
            <div class="kpi-row">
                <div class="kpi-chip"><span class="kpi-label">FFE:</span><span class="kpi-value">${Math.round(totalFFE)}/${totalCap}</span></div>
                <div class="kpi-chip"><span class="kpi-label">Util:</span><span class="kpi-value">${((totalFFE/totalCap)*100).toFixed(1)}%</span></div>
            </div>
            <div style="position:relative;height:200px;"><canvas id="${chartId}"></canvas></div>`;
        return panel;
    }

    // ============================================================
    // MINI-CHARTS WITH SLOPE MARKERS (Sketch 1)
    // ============================================================

    function createMiniChart(ds) {
        const {config, dailyData, zScores, cdfValues, slopeSpikes} = ds;
        const ctx = document.getElementById(`chart-${config.id}`);
        if (!ctx) return;

        const labels = dailyData.map(d=>d.dtd);
        const cumData = dailyData.map(d=>d.cumFFE);
        const bookingDates = dailyData.map(d=>d.bookingDate.toISOString().split('T')[0]);

        // Slope spike markers: show as red scatter points
        const slopeSpikeData = cumData.map((v,i) => slopeSpikes[i] && slopeSpikes[i].isSpike ? v : null);

        // Forecast band
        const last = cumData[cumData.length-1]||0;
        const upper = cumData.map((v,i)=>v+(last*0.15*i/cumData.length));
        const lower = cumData.map((v,i)=>Math.max(0,v-(last*0.15*i/cumData.length)));

        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels,
                datasets: [
                    { label:'Cumulative FFE', data:cumData, borderColor:config.color, borderWidth:2.5, pointRadius:0, pointHoverRadius:5, fill:false, tension:0.2 },
                    { label:'Forecast Upper', data:upper, borderColor:'rgba(50,205,50,0.4)', borderWidth:1, pointRadius:0, fill:false, borderDash:[4,4], tension:0.3 },
                    { label:'Forecast Lower', data:lower, borderColor:'rgba(255,99,71,0.4)', borderWidth:1, pointRadius:0, fill:'-1', backgroundColor:'rgba(100,100,100,0.08)', borderDash:[4,4], tension:0.3 },
                    { label:'Capacity', data:labels.map(()=>config.capacity), borderColor:'rgba(255,255,255,0.25)', borderWidth:1, borderDash:[10,5], pointRadius:0, fill:false },
                    { label:'Slope Spikes', data:slopeSpikeData, type:'scatter', pointRadius:8, pointStyle:'circle',
                      pointBackgroundColor:'rgba(229,62,62,0.3)', pointBorderColor:'rgba(229,62,62,0.9)', pointBorderWidth:2,
                      showLine:false }
                ]
            },
            options: {
                responsive:true, maintainAspectRatio:false,
                interaction:{ mode:'index', intersect:false },
                scales: {
                    x:{ reverse:false, title:{display:true,text:'DTD',color:'rgb(138,138,138)',font:{size:10}}, grid:{color:'rgba(138,138,138,0.15)'}, ticks:{color:'rgb(138,138,138)',font:{size:9},maxTicksLimit:8,maxRotation:0} },
                    y:{ beginAtZero:true, title:{display:true,text:'FFE',color:'rgb(138,138,138)',font:{size:10}}, grid:{color:'rgba(138,138,138,0.15)'}, ticks:{color:'rgb(138,138,138)',font:{size:9}} }
                },
                plugins: {
                    legend:{ display:false },
                    tooltip: {
                        backgroundColor:'rgba(0,0,0,0.9)', titleFont:{size:12}, bodyFont:{size:11},
                        callbacks: {
                            title: ctx => { const i=ctx[0].dataIndex; return `DTD ${labels[i]} â€” ${bookingDates[i]}`; },
                            afterBody: ctx => {
                                const i=ctx[0].dataIndex;
                                const ss = slopeSpikes[i];
                                const lines = [
                                    `Daily FFE: ${dailyData[i].bookedFFE.toFixed(1)}`,
                                    `Z-Score: ${zScores[i].toFixed(2)}  CDF: ${cdfValues[i].toFixed(3)}`,
                                    `Slope: ${ss.slope.toFixed(2)}  Expected: ${ss.expected.toFixed(2)}`,
                                    `Deviation: ${ss.deviation.toFixed(1)}Ïƒ ${ss.isSpike ? 'ğŸš¨ ANOMALY' : ''}`
                                ];
                                return lines;
                            }
                        }
                    }
                },
                onHover: (event, elements) => {
                    if (elements.length > 0) { crossHighlight(bookingDates[elements[0].index], config.id); }
                    else { clearHighlight(); }
                }
            }
        });
        chart._bookingDates = bookingDates;
        chart._departureId = config.id;
        chartInstances[config.id] = chart;
    }

    function createAggGroupChart(name, datasets) {
        const chartId = 'chart-agg-'+name.replace(/[^a-zA-Z0-9]/g,'');
        const ctx = document.getElementById(chartId);
        if (!ctx) return;
        const labels=[]; const aggData=[];
        for(let dtd=SIM_CONFIG.horizonDays;dtd>=0;dtd--){ labels.push(dtd); let t=0; datasets.forEach(ds=>{const r=ds.dailyData.find(d=>d.dtd===dtd);if(r)t+=r.cumFFE;}); aggData.push(t); }
        const totalCap=datasets.reduce((s,d)=>s+d.config.capacity,0);
        const chart = new Chart(ctx,{type:'line',data:{labels,datasets:[{label:'Total FFE',data:aggData,borderColor:datasets[0].config.color,borderWidth:2.5,pointRadius:0,fill:true,backgroundColor:datasets[0].config.color.replace('rgb','rgba').replace(')',',0.08)'),tension:0.2},{label:'Capacity',data:labels.map(()=>totalCap),borderColor:'rgba(255,255,255,0.25)',borderWidth:1,borderDash:[10,5],pointRadius:0,fill:false}]},options:{responsive:true,maintainAspectRatio:false,scales:{x:{grid:{color:'rgba(138,138,138,0.15)'},ticks:{color:'rgb(138,138,138)',font:{size:9},maxTicksLimit:8,maxRotation:0}},y:{beginAtZero:true,grid:{color:'rgba(138,138,138,0.15)'},ticks:{color:'rgb(138,138,138)',font:{size:9}}}},plugins:{legend:{display:false},tooltip:{backgroundColor:'rgba(0,0,0,0.85)'}}}});
        chartInstances['agg-'+name.replace(/[^a-zA-Z0-9]/g,'')] = chart;
    }

    // ============================================================
    // TIME SERIES CHART (Sketch 2)
    // ============================================================

    function renderTimeseriesChart() {
        if (chartInstances['timeseries']) { chartInstances['timeseries'].destroy(); }
        const ctx = document.getElementById('timeseriesChart');
        if (!ctx) return;

        const bucketDefs = getBucketDefs();
        const labels = bucketData[bucketDefs[0].label]?.dates || [];
        const shortLabels = labels.map(d => d.slice(5)); // MM-DD

        // Build legend
        const legendEl = document.getElementById('bucketLegend');
        legendEl.innerHTML = bucketDefs.map((b, i) => {
            const c = BUCKET_COLORS[i % BUCKET_COLORS.length];
            return `<div class="bucket-legend-item"><div class="bucket-swatch" style="background:${c}"></div>${b.label}</div>`;
        }).join('');

        const datasets = [];
        bucketDefs.forEach((b, i) => {
            const bd = bucketData[b.label];
            if (!bd) return;
            const c = BUCKET_COLORS[i % BUCKET_COLORS.length];
            const ca = c.replace('rgb','rgba').replace(')',',0.15)');

            // Main line
            datasets.push({ label:b.label, data:bd.values, borderColor:c, borderWidth:2, pointRadius:0, fill:false, tension:0.3 });
            // Upper band
            datasets.push({ label:b.label+' upper', data:bd.upper, borderColor:c.replace('rgb','rgba').replace(')',',0.3)'), borderWidth:1, borderDash:[3,3], pointRadius:0, fill:false, tension:0.3 });
            // Lower band (fill to upper)
            datasets.push({ label:b.label+' lower', data:bd.lower, borderColor:c.replace('rgb','rgba').replace(')',',0.3)'), borderWidth:1, borderDash:[3,3], pointRadius:0, fill:'-1', backgroundColor:ca, tension:0.3 });

            // Anomaly markers
            const threshold = parseFloat(document.getElementById('spikeThreshold').value) || 0.95;
            const anomalyData = bd.values.map((v, j) => (bd.cdfValues[j] > threshold || bd.cdfValues[j] < (1-threshold)) ? v : null);
            datasets.push({ label:b.label+' anomaly', data:anomalyData, type:'scatter', pointRadius:6, pointStyle:'circle',
                pointBackgroundColor:'rgba(229,62,62,0.4)', pointBorderColor:'rgba(229,62,62,0.9)', pointBorderWidth:2, showLine:false });
        });

        const tsChart = new Chart(ctx, {
            type: 'line',
            data: { labels: shortLabels, datasets },
            options: {
                responsive:true, maintainAspectRatio:false,
                interaction:{ mode:'index', intersect:false },
                scales: {
                    x:{ title:{display:true,text:'Booking Date',color:'rgb(180,180,180)',font:{size:12}}, grid:{color:'rgba(138,138,138,0.15)'}, ticks:{color:'rgb(138,138,138)',font:{size:9},maxTicksLimit:15,maxRotation:45,minRotation:45} },
                    y:{ beginAtZero:true, title:{display:true,text:'Daily FFE (by bucket)',color:'rgb(180,180,180)',font:{size:12}}, grid:{color:'rgba(138,138,138,0.15)'}, ticks:{color:'rgb(138,138,138)',font:{size:10}} }
                },
                plugins: {
                    legend:{ display:false },
                    tooltip: {
                        backgroundColor:'rgba(0,0,0,0.9)',
                        callbacks: {
                            title: ctx => labels[ctx[0].dataIndex] || '',
                            label: ctx => {
                                if (ctx.dataset.label.includes('upper')||ctx.dataset.label.includes('lower')||ctx.dataset.label.includes('anomaly')) return null;
                                return `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(1)} FFE`;
                            }
                        }
                    }
                },
                onHover: (event, elements) => {
                    if (elements.length > 0) { crossHighlight(labels[elements[0].index], 'timeseries'); }
                    else { clearHighlight(); }
                }
            }
        });
        tsChart._bookingDates = labels; // full ISO dates for cross-highlight
        chartInstances['timeseries'] = tsChart;
    }

    // ============================================================
    // AGGREGATE STACKED CHART (Sketch 3)
    // ============================================================

    function renderAggregateCharts() {
        if (chartInstances['aggregate']) chartInstances['aggregate'].destroy();
        if (chartInstances['aggZScore']) chartInstances['aggZScore'].destroy();

        const bucketDefs = getBucketDefs();
        const dates = bucketData[bucketDefs[0].label]?.dates || [];
        const shortLabels = dates.map(d => d.slice(5));

        // Legend
        const legendEl = document.getElementById('aggBucketLegend');
        legendEl.innerHTML = bucketDefs.map((b, i) => {
            const c = BUCKET_COLORS[i % BUCKET_COLORS.length];
            return `<div class="bucket-legend-item"><div class="bucket-swatch" style="background:${c}"></div>${b.label}</div>`;
        }).join('');

        // Stacked area datasets
        const stackedDatasets = bucketDefs.map((b, i) => {
            const bd = bucketData[b.label];
            const c = BUCKET_COLORS[i % BUCKET_COLORS.length];
            return {
                label: b.label, data: bd ? bd.values : [],
                borderColor: c, borderWidth: 1.5,
                backgroundColor: c.replace('rgb','rgba').replace(')',',0.35)'),
                fill: true, tension: 0.3, pointRadius: 0, stack: 'stack0'
            };
        });

        // Anomaly scatter on aggregate total
        const aggTotals = dates.map(d => aggregateByDate[d]?.total || 0);
        const threshold = parseFloat(document.getElementById('spikeThreshold').value) || 0.95;
        const anomalyMarkers = dates.map((d, i) => {
            const entry = aggregateByDate[d];
            if (!entry || !entry.cdfValues.length) return null;
            const avgCDF = entry.cdfValues.reduce((a,b)=>a+b,0)/entry.cdfValues.length;
            return (avgCDF > threshold || avgCDF < (1-threshold) || entry.slopeFlags >= 2) ? aggTotals[i] : null;
        });

        stackedDatasets.push({
            label: 'Anomalies', data: anomalyMarkers, type:'scatter',
            pointRadius: 10, pointStyle: 'circle',
            pointBackgroundColor: 'rgba(229,62,62,0.2)', pointBorderColor: 'rgba(229,62,62,1)', pointBorderWidth: 2.5,
            showLine: false, stack: undefined
        });

        const aggCtx = document.getElementById('aggregateChart');
        const aggChart = new Chart(aggCtx, {
            type: 'line',
            data: { labels: shortLabels, datasets: stackedDatasets },
            options: {
                responsive:true, maintainAspectRatio:false,
                interaction:{ mode:'index', intersect:false },
                scales: {
                    x:{ title:{display:true,text:'Booking Date',color:'rgb(180,180,180)',font:{size:12}}, grid:{color:'rgba(138,138,138,0.15)'}, ticks:{color:'rgb(138,138,138)',font:{size:9},maxTicksLimit:15,maxRotation:45,minRotation:45}, stacked:true },
                    y:{ beginAtZero:true, title:{display:true,text:'Total FFE (Stacked)',color:'rgb(180,180,180)',font:{size:12}}, grid:{color:'rgba(138,138,138,0.15)'}, ticks:{color:'rgb(138,138,138)',font:{size:10}}, stacked:true }
                },
                plugins: {
                    legend:{ display:false },
                    tooltip: {
                        backgroundColor:'rgba(0,0,0,0.9)',
                        callbacks: {
                            title: ctx => dates[ctx[0].dataIndex] || '',
                            label: ctx => {
                                if (ctx.dataset.label === 'Anomalies') return ctx.parsed.y !== null ? 'ğŸš¨ Anomaly' : null;
                                return `${ctx.dataset.label}: ${ctx.parsed.y?.toFixed(1) || 0} FFE`;
                            }
                        }
                    }
                },
                onHover: (event, elements) => {
                    if (elements.length > 0) { crossHighlight(dates[elements[0].index], 'aggregate'); }
                    else { clearHighlight(); }
                }
            }
        });
        aggChart._bookingDates = dates;
        chartInstances['aggregate'] = aggChart;

        // Z-Score chart
        const aggZScoreValues = dates.map(d => {
            const entry = aggregateByDate[d];
            if (!entry || !entry.zScores.length) return 0;
            return entry.zScores.reduce((a,b)=>a+b,0)/entry.zScores.length;
        });

        const zCtx = document.getElementById('aggZScoreChart');
        chartInstances['aggZScore'] = new Chart(zCtx, {
            type: 'bar',
            data: {
                labels: shortLabels,
                datasets: [{
                    label: 'Avg Z-Score',
                    data: aggZScoreValues,
                    backgroundColor: aggZScoreValues.map(z => z > 2 ? 'rgba(229,62,62,0.7)' : z < -2 ? 'rgba(0,143,211,0.7)' : 'rgba(138,138,138,0.4)'),
                    borderWidth: 0, barPercentage: 0.8
                }]
            },
            options: {
                responsive:true, maintainAspectRatio:false,
                scales: {
                    x:{ grid:{color:'rgba(138,138,138,0.15)'}, ticks:{color:'rgb(138,138,138)',font:{size:8},maxTicksLimit:15,maxRotation:45,minRotation:45} },
                    y:{ grid:{color:'rgba(138,138,138,0.15)'}, ticks:{color:'rgb(138,138,138)',font:{size:9}} }
                },
                plugins: {
                    legend:{ display:false },
                    tooltip:{ backgroundColor:'rgba(0,0,0,0.85)' },
                    annotation: {
                        annotations: {
                            upperThresh: { type:'line', yMin:2, yMax:2, borderColor:'rgba(229,62,62,0.6)', borderWidth:1.5, borderDash:[6,4], label:{content:'+2Ïƒ',display:true,color:'rgba(229,62,62,0.8)',font:{size:10},position:'start'} },
                            lowerThresh: { type:'line', yMin:-2, yMax:-2, borderColor:'rgba(0,143,211,0.6)', borderWidth:1.5, borderDash:[6,4], label:{content:'-2Ïƒ',display:true,color:'rgba(0,143,211,0.8)',font:{size:10},position:'start'} }
                        }
                    }
                }
            }
        });
    }

    // ============================================================
    // VIEW TABS
    // ============================================================

    function switchView(viewId) {
        document.querySelectorAll('.view-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.view-section').forEach(s => s.classList.remove('active'));
        document.getElementById('view-'+viewId).classList.add('active');
        document.querySelector(`.view-tab[onclick*="${viewId}"]`).classList.add('active');
    }

    // ============================================================
    // CROSS-HIGHLIGHTING
    // ============================================================

    function crossHighlight(dateStr, sourceId) {
        currentHighlightDate = dateStr;
        document.getElementById('crossDateLabel').textContent = `ğŸ“… ${dateStr}`;
        document.getElementById('crossDateLabel').style.display = 'block';

        Object.entries(chartInstances).forEach(([id, chart]) => {
            if (!chart._bookingDates) return;
            // Match date: _bookingDates may be full ISO or short MM-DD
            let idx = chart._bookingDates.indexOf(dateStr);
            if (idx === -1) {
                // Try matching by date suffix (MM-DD)
                const shortDate = dateStr.slice(5); // MM-DD
                idx = chart._bookingDates.indexOf(shortDate);
            }
            if (idx === -1) {
                // Try finding a full date that ends with the short version
                idx = chart._bookingDates.findIndex(d => d === dateStr || d.endsWith(dateStr.slice(5)));
            }

            // For aggZScore chart, skip annotation (it uses different plugin config)
            if (id === 'aggZScore') return;

            if (idx === -1) {
                if (chart.options?.plugins?.annotation) {
                    chart.options.plugins.annotation = {annotations:{}};
                    chart.update('none');
                }
                return;
            }
            chart.options.plugins.annotation = { annotations: { crossLine: {
                type:'line', xMin:idx, xMax:idx,
                borderColor: id===sourceId ? 'rgba(255,255,255,0.8)' : 'rgba(0,143,211,0.6)',
                borderWidth: id===sourceId ? 2 : 1.5,
                borderDash: id===sourceId ? [] : [4,4]
            }}};
            chart.update('none');
        });
        updateAggMetrics(dateStr);
    }

    function clearHighlight() {
        currentHighlightDate = null;
        document.getElementById('crossDateLabel').style.display = 'none';
        document.getElementById('aggMetrics').style.display = 'none';
        Object.values(chartInstances).forEach(chart => {
            if (chart.options?.plugins?.annotation) { chart.options.plugins.annotation = {annotations:{}}; chart.update('none'); }
        });
    }

    function highlightDate(dateStr) {
        crossHighlight(dateStr, null);
        document.querySelectorAll('.spike-table tr').forEach(row => {
            row.classList.toggle('active', row.querySelector('td') && row.querySelector('td').textContent === dateStr);
        });
    }

    function updateAggMetrics(dateStr) {
        const m = document.getElementById('aggMetrics');
        m.style.display = 'flex';
        let totalBookings=0, zScores=[], cdfValues=[], totalSlope=0, slopeCount=0;
        Object.values(departureDataSets).forEach(ds => {
            const idx = ds.dailyData.findIndex(d=>d.bookingDate.toISOString().split('T')[0]===dateStr);
            if (idx>=0) {
                totalBookings += ds.dailyData[idx].bookedFFE;
                zScores.push(ds.zScores[idx]||0);
                cdfValues.push(ds.cdfValues[idx]||0.5);
                if (ds.slopeSpikes[idx]) { totalSlope += ds.slopeSpikes[idx].slope; slopeCount++; }
            }
        });
        document.getElementById('aggDate').textContent = dateStr;
        document.getElementById('aggBookings').textContent = totalBookings.toFixed(1)+' FFE';
        document.getElementById('aggSlope').textContent = slopeCount > 0 ? (totalSlope/slopeCount).toFixed(2) : 'â€”';
        document.getElementById('aggZScore').textContent = zScores.length ? (zScores.reduce((a,b)=>a+b,0)/zScores.length).toFixed(2) : 'â€”';
        document.getElementById('aggCDF').textContent = cdfValues.length ? (cdfValues.reduce((a,b)=>a+b,0)/cdfValues.length).toFixed(3) : 'â€”';
        const th = parseFloat(document.getElementById('spikeThreshold').value)||0.95;
        document.getElementById('aggSpikeCount').textContent = cdfValues.filter(c=>c>th||c<(1-th)).length+'/'+cdfValues.length;
    }

    // ============================================================
    // GLOBAL INDICATORS
    // ============================================================

    function updateGlobalIndicators() {
        const allCanary = Object.values(departureDataSets).map(ds=>ds.canarySignal);
        const globalSignal = allCanary.reduce((a,b)=>a+b,0)/allCanary.length;
        const el = document.getElementById('globalCanaryValue');
        el.textContent = globalSignal.toFixed(2);
        el.style.color = globalSignal>0.7?'var(--maersk-success)':globalSignal>0.3?'var(--maersk-warning)':'var(--maersk-error)';
        const totalFFE = Object.values(departureDataSets).reduce((s,ds)=>{ const l=ds.dailyData[ds.dailyData.length-1]; return s+(l?l.cumFFE:0); },0);
        document.getElementById('globalTotalBookings').textContent = Math.round(totalFFE)+' FFE';
    }

    function updateAggregation() {
        if (!Object.keys(departureDataSets).length) return;
        renderDashboard();
        renderTimeseriesChart();
        renderAggregateCharts();
    }

    // ============================================================
    // INIT
    // ============================================================
    window.addEventListener('load', generateAll);
    </script>
</body>
</html>
