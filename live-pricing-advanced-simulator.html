<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced FFE Booking Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script src="styles/chart-config.js"></script>
    <link rel="stylesheet" href="styles/maersk-theme.css">
    <style>
        /* Tooltip styles */
        .param-label-with-tooltip {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .tooltip-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--maersk-info, #0070ad);
            color: white;
            font-size: 11px;
            font-weight: bold;
            cursor: help;
            position: relative;
        }
        
        .tooltip-icon:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 50%;
            bottom: 24px;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: normal;
            white-space: normal;
            width: 250px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            line-height: 1.4;
        }
        
        .tooltip-icon:hover::before {
            content: '';
            position: absolute;
            left: 50%;
            bottom: 18px;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
            z-index: 1001;
        }
        
        /* Button hover effects */
        button:not(:disabled):hover {
            opacity: 0.9;
            transform: translateY(-1px);
            transition: all 0.2s ease;
        }
        
        button:not(:disabled):active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>üö¢ Advanced Booking Simulator</h1>
        <p>Sophisticated Multi-Channel FFE Booking Model with Cancellations & Capacity</p>
    </header>

    <div class="container">
        <div class="demo-note">
            <h3>‚ö° Advanced Simulator - Jun 30 Departure</h3>
            <p>Experience a realistic booking system with search patterns, pricing ratios, cancellation economics, and capacity constraints. Adjust parameters to see how different strategies affect the uptake curve.</p>
        </div>
        
        <!-- Turn-Based Simulation Controls -->
        <div style="background: var(--mds-bg-secondary); padding: 1rem; border-radius: 8px; margin: 1.5rem 0; border: 2px solid var(--maersk-blue);">
            <h4 style="text-align: center; margin: 0 0 1rem 0; color: var(--mds-text-primary);">üéÆ Turn-Based Simulator</h4>
            
            <!-- Turn Status -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding: 0.8rem; background: var(--mds-bg-tertiary); border-radius: 6px;">
                <div>
                    <span style="color: var(--mds-text-secondary); font-size: 0.9rem;">Current Turn:</span>
                    <span style="color: var(--maersk-blue); font-weight: 700; font-size: 1.2rem; margin-left: 0.5rem;" id="currentTurn">1</span>
                    <span style="color: var(--mds-text-secondary); font-size: 0.9rem; margin-left: 0.5rem;">of 7</span>
                </div>
                <div>
                    <span style="color: var(--mds-text-secondary); font-size: 0.9rem;">Days Remaining:</span>
                    <span style="color: var(--maersk-warning); font-weight: 700; font-size: 1.2rem; margin-left: 0.5rem;" id="daysRemaining">49-43</span>
                </div>
                <div>
                    <span style="color: var(--mds-text-secondary); font-size: 0.9rem;">Vessel Status:</span>
                    <span style="font-weight: 600; margin-left: 0.5rem;" id="vesselStatus">üîí Closed</span>
                </div>
            </div>

            <!-- Forecast Summary -->
            <div style="margin-bottom: 1rem; padding: 0.8rem; background: var(--mds-bg-tertiary); border-radius: 6px; border: 1px solid var(--mds-border-default);">
                <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem;">
                    <div>
                        <span style="color: var(--mds-text-secondary);">üîÆ Projected Final:</span>
                        <span id="projectedFinal" style="color: var(--maersk-blue); font-weight: 600; margin-left: 0.5rem;">-- FFE</span>
                    </div>
                    <div>
                        <span style="color: var(--mds-text-secondary);">Range:</span>
                        <span id="projectedRange" style="color: var(--mds-text-primary); font-weight: 500; margin-left: 0.5rem;">-- to -- FFE</span>
                    </div>
                    <div>
                        <span style="color: var(--mds-text-secondary);">Capacity:</span>
                        <span id="capacityUtilForecast" style="color: var(--maersk-warning); font-weight: 600; margin-left: 0.5rem;">--%</span>
                    </div>
                </div>
            </div>

            <!-- Canary Early Warning Indicator -->
            <div id="canaryWarning" style="display: none; margin-bottom: 1rem; padding: 0.8rem; background: linear-gradient(135deg, rgba(255, 193, 7, 0.1) 0%, rgba(255, 152, 0, 0.1) 100%); border-radius: 6px; border: 2px solid var(--maersk-warning, #b35a00); box-shadow: 0 2px 8px rgba(255, 152, 0, 0.2);">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="display: flex; align-items: center; gap: 0.75rem;">
                        <div style="font-size: 1.5rem;">üê¶</div>
                        <div>
                            <div style="color: var(--mds-text-primary); font-weight: 700; font-size: 0.9rem; margin-bottom: 0.25rem;">Canary Early Warning</div>
                            <div id="canaryDirection" style="font-size: 0.8rem; font-weight: 600;">-- Shock Detected</div>
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="color: var(--mds-text-secondary); font-size: 0.75rem; margin-bottom: 0.25rem;">Signal Strength</div>
                        <div style="font-size: 1.8rem; font-weight: 700; line-height: 1;" id="canarySignal">0.00</div>
                    </div>
                </div>
                <div style="margin-top: 0.5rem; padding: 0.5rem; background: rgba(0, 0, 0, 0.2); border-radius: 4px; font-size: 0.75rem; color: var(--mds-text-secondary);">
                    <strong>Note:</strong> Market price volatility shock detected. Booking velocity and forecasts will be affected.
                </div>
            </div>

            <!-- Turn Controls -->
            <div style="display: flex; gap: 1rem; justify-content: center; align-items: center; margin-bottom: 1rem; flex-wrap: wrap;">
                <button id="simulateTurnBtn" onclick="simulateTurn()" 
                        style="background: var(--maersk-blue); color: white; border: none; padding: 0.8rem 2rem; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                    üéØ Simulate Turn
                </button>
                <button onclick="resetSimulation()" 
                        style="background: var(--mds-bg-strong); color: var(--mds-text-secondary); border: 1px solid var(--mds-border-default); padding: 0.8rem 1.5rem; border-radius: 6px; font-size: 0.9rem; cursor: pointer;">
                    üîÑ Reset Simulation
                </button>
                <button onclick="resetAllParameters()" 
                        style="background: var(--mds-bg-strong); color: var(--mds-text-secondary); border: 1px solid var(--mds-border-default); padding: 0.8rem 1.5rem; border-radius: 6px; font-size: 0.9rem; cursor: pointer;"
                        title="Reset all parameters to default values">
                    ‚öôÔ∏è Reset Parameters
                </button>
            </div>
        </div>

        <!-- Core Parameters Panel -->
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin: 1.5rem 0; background: var(--mds-bg-secondary); padding: 1rem; border-radius: 8px;">
            <h4 style="grid-column: 1 / -1; text-align: center; margin: 0 0 1rem 0; color: var(--mds-text-primary);">üéõÔ∏è Decision Parameters (Adjust Each Turn)</h4>
            
            <!-- Capacity -->
            <div style="background: var(--mds-bg-tertiary); padding: 12px; border-radius: 6px; border-left: 3px solid var(--maersk-blue);">
                <label for="capacity" style="display: block; font-weight: 600; margin-bottom: 4px;">üö¢ Capacity (FFE):</label>
                <input type="number" id="capacity" value="200" min="50" max="500" step="10" 
                       style="width: 100%; background: var(--mds-bg-primary); color: var(--mds-text-primary); border: 1px solid var(--mds-border-default); border-radius: 4px; padding: 6px; font-size: 14px;">
            </div>
            
            <!-- Market Price -->
            <div style="background: var(--mds-bg-tertiary); padding: 12px; border-radius: 6px; border-left: 3px solid var(--maersk-warning);">
                <label for="marketPrice" style="display: block; font-weight: 600; margin-bottom: 4px;">üí∞ Market Price ($):</label>
                <input type="number" id="marketPrice" value="3000" min="0" max="10000" step="50" 
                       style="width: 100%; background: var(--mds-bg-primary); color: var(--mds-text-primary); border: 1px solid var(--mds-border-default); border-radius: 4px; padding: 6px; font-size: 14px;"
                       oninput="updateChannelMarkupDisplay(); updateChartsWithTurnData()">
            </div>
            
            <!-- Channel Price -->
            <div style="background: var(--mds-bg-tertiary); padding: 12px; border-radius: 6px; border-left: 3px solid var(--maersk-info);">
                <label for="channelPrice" style="display: block; font-weight: 600; margin-bottom: 4px;">üìä Channel Price ($):</label>
                <input type="number" id="channelPrice" value="3090" min="0" max="10000" step="10" 
                       style="width: 100%; background: var(--mds-bg-primary); color: var(--mds-text-primary); border: 1px solid var(--mds-border-default); border-radius: 4px; padding: 6px; font-size: 14px;"
                       oninput="updateChannelMarkupDisplay(); updateChartsWithTurnData()">
                <div style="color: var(--mds-text-weak); font-size: 0.7rem; margin-top: 0.25rem;" id="channelMarkupDisplay">
                    Markup: 3.0%
                </div>
            </div>
            
            <!-- Price Sensitivity -->
            <div style="background: var(--mds-bg-tertiary); padding: 12px; border-radius: 6px; border-left: 3px solid var(--maersk-success);">
                <label for="sensitivity" style="display: block; font-weight: 600; margin-bottom: 4px;">üìà Price Sensitivity:</label>
                <select id="sensitivity" 
                        style="width: 100%; background: var(--mds-bg-primary); color: var(--mds-text-primary); border: 1px solid var(--mds-border-default); border-radius: 4px; padding: 6px; font-size: 14px;"
                        onchange="toggleCustomSensitivity(); updateChartsWithTurnData()">
                    <option value="0.5">üìà Conservative</option>
                    <option value="1.0">üéØ Balanced</option>
                    <option value="1.25" selected>‚ö° Moderate</option>
                    <option value="2.0">üî• Aggressive</option>
                    <option value="3.0">üí• Extreme</option>
                    <option value="custom">üßÆ Custom</option>
                </select>
                <input type="number" id="customSensitivity" value="1.25" min="0.1" max="5.0" step="0.1" 
                       style="width: 100%; background: var(--mds-bg-primary); color: var(--mds-text-primary); border: 1px solid var(--mds-border-default); border-radius: 4px; padding: 6px; font-size: 14px; margin-top: 4px; display: none;"
                       oninput="updateChartsWithTurnData()">
            </div>
            
            <!-- Booking Conversion -->
            <div style="background: var(--mds-bg-tertiary); padding: 12px; border-radius: 6px; border-left: 3px solid var(--maersk-light-blue);">
                <label for="bookingConversion" style="display: block; font-weight: 600; margin-bottom: 4px;">üéØ Booking Conversion:</label>
                <input type="number" id="bookingConversion" value="0.03" min="0.01" max="0.50" step="0.01" 
                       style="width: 100%; background: var(--mds-bg-primary); color: var(--mds-text-primary); border: 1px solid var(--mds-border-default); border-radius: 4px; padding: 6px; font-size: 14px;"
                       oninput="updateChartsWithTurnData()">
                <div style="color: var(--mds-text-weak); font-size: 0.7rem; margin-top: 0.25rem;">
                    FFE per offer (base rate)
                </div>
            </div>

            <!-- Vessel Opening Decision -->
            <div style="background: var(--mds-bg-tertiary); padding: 12px; border-radius: 6px; border-left: 3px solid var(--maersk-success);">
                <label style="display: block; font-weight: 600; margin-bottom: 8px;">üö¢ Vessel Opening:</label>
                <button id="openVesselBtn" onclick="openVessel()" 
                        style="width: 100%; background: var(--maersk-success); color: white; border: none; padding: 8px; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">
                    üîì Open Vessel for Booking
                </button>
                <div style="color: var(--mds-text-weak); font-size: 0.7rem; margin-top: 0.25rem;" id="openingHelp">
                    One-time decision - cannot close after opening
                </div>
            </div>
        </div>
        
        <!-- Advanced Parameters (Collapsible) -->
        <div style="margin: 1rem 0; padding: 1rem; background: var(--mds-bg-secondary); border-radius: 8px; border: 1px solid var(--mds-border-default);">
            <div style="text-align: center; cursor: pointer; user-select: none;" onclick="toggleAdvancedParams()" id="advancedToggle">
                <span style="color: var(--mds-text-secondary); font-size: 0.9rem; font-weight: 500;">
                    ‚öôÔ∏è Advanced Parameters
                    <span id="advancedArrow" style="margin-left: 0.5rem; transition: transform 0.3s ease;">‚ñº</span>
                </span>
            </div>
            
            <div id="advancedContent" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--mds-border-default);">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                    
                    <!-- Demand Curve Parameters -->
                    <div style="grid-column: 1 / -1; color: var(--mds-text-secondary); font-size: 0.9rem; font-weight: 600; margin-bottom: 0.5rem;">
                        üìä Demand Curve Parameters
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Base Weekday Volume</label>
                        <input type="number" id="baseWeekdayVolume" value="500" min="200" max="2000" step="50" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <div>
                        <div class="param-label-with-tooltip" style="margin-bottom: 0.25rem;">
                            <label style="color: var(--mds-text-secondary); font-size: 0.8rem;">Ramp Start (DTD)</label>
                            <span class="tooltip-icon" data-tooltip="Days before departure when booking demand starts ramping up significantly. Example: 28 means demand increases starting 28 days out.">?</span>
                        </div>
                        <input type="number" id="rampStart" value="28" min="20" max="40" step="1" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <div>
                        <div class="param-label-with-tooltip" style="margin-bottom: 0.25rem;">
                            <label style="color: var(--mds-text-secondary); font-size: 0.8rem;">Taper Start (DTD)</label>
                            <span class="tooltip-icon" data-tooltip="Days before departure when booking demand starts tapering off. Example: 5 means demand decreases inside 5 days to departure.">?</span>
                        </div>
                        <input type="number" id="taperStart" value="5" min="2" max="10" step="1" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Weekend Multiplier</label>
                        <input type="number" id="weekendMultiplier" value="0.20" min="0.01" max="0.8" step="0.05" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <!-- Cancellation Parameters -->
                    <div style="grid-column: 1 / -1; color: var(--mds-text-secondary); font-size: 0.9rem; font-weight: 600; margin: 1rem 0 0.5rem 0;">
                        üîÑ Cancellation Economics
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Cancellation Fee ($)</label>
                        <input type="number" id="cancellationFee" value="250" min="0" max="500" step="25" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <div>
                        <div class="param-label-with-tooltip" style="margin-bottom: 0.25rem;">
                            <label style="color: var(--mds-text-secondary); font-size: 0.8rem;">Fee Pass-Through (%)</label>
                            <span class="tooltip-icon" data-tooltip="Percentage of the cancellation fee that customers receive as credit. Example: 15% means if fee is $250, customer gets $37.50 credit.">?</span>
                        </div>
                        <input type="number" id="feePassThrough" value="15" min="0" max="50" step="5" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <div>
                        <div class="param-label-with-tooltip" style="margin-bottom: 0.25rem;">
                            <label style="color: var(--mds-text-secondary); font-size: 0.8rem;">Cancel Cap per Day (%)</label>
                            <span class="tooltip-icon" data-tooltip="Maximum percentage of current bookings that can cancel per day. Example: 5% means at most 5% of booked FFE can cancel on any given day.">?</span>
                        </div>
                        <input type="number" id="cancelCap" value="5" min="1" max="10" step="0.5" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <div>
                        <div class="param-label-with-tooltip" style="margin-bottom: 0.25rem;">
                            <label style="color: var(--mds-text-secondary); font-size: 0.8rem;">No Cancel Inside (DTD)</label>
                            <span class="tooltip-icon" data-tooltip="Cancellations are not allowed within this many days of departure. Example: 5 means no cancellations allowed inside 5 days to departure.">?</span>
                        </div>
                        <input type="number" id="noCancelInside" value="5" min="0" max="10" step="1" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <!-- Opening Policy -->
                    <div style="grid-column: 1 / -1; color: var(--mds-text-secondary); font-size: 0.9rem; font-weight: 600; margin: 1rem 0 0.5rem 0;">
                        üìÖ Opening Policy
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Open Weeks Before</label>
                        <input type="number" id="openWeeksBefore" value="4" min="1" max="12" step="1" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>

                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Expected Open Date (DTD)</label>
                        <input type="number" id="expectedOpenDTD" value="28" min="5" max="45" step="1" 
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                        <div style="color: var(--mds-text-weak); font-size: 0.7rem; margin-top: 0.25rem;">
                            For forecast calculations only
                        </div>
                    </div>

                    <div>
                        <div class="param-label-with-tooltip" style="margin-bottom: 0.25rem;">
                            <label style="color: var(--mds-text-secondary); font-size: 0.8rem;">Target Guardrail Buffer (%)</label>
                            <span class="tooltip-icon" data-tooltip="Acceptable range around capacity target. Example: 5% with 200 FFE capacity means 190-210 FFE is 'on target' (green). Outside this range triggers warnings.">?</span>
                        </div>
                        <input type="number" id="guardrailBuffer" value="5" min="1" max="20" step="1" 
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                        <div style="color: var(--mds-text-weak); font-size: 0.7rem; margin-top: 0.25rem;">
                            Threshold around capacity target
                        </div>
                    </div>

                    <!-- Market Volatility -->
                    <div style="grid-column: 1 / -1; color: var(--mds-text-secondary); font-size: 0.9rem; font-weight: 600; margin: 1rem 0 0.5rem 0;">
                        üìä Market Volatility
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Market Price Volatility (%)</label>
                        <input type="number" id="marketPriceVolatility" value="3" min="0" max="15" step="0.5" 
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                        <div style="color: var(--mds-text-weak); font-size: 0.7rem; margin-top: 0.25rem;">
                            Random price change per turn
                        </div>
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Search Volume Volatility (%)</label>
                        <input type="number" id="searchVolatility" value="10" min="0" max="30" step="1" 
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                        <div style="color: var(--mds-text-weak); font-size: 0.7rem; margin-top: 0.25rem;">
                            Random search variation
                        </div>
                    </div>
                </div>
                
                <!-- Reset Button -->
                <div style="text-align: center; margin-top: 1rem;">
                    <button onclick="resetParameters()" 
                            style="background: var(--mds-bg-strong); color: var(--mds-text-secondary); border: 1px solid var(--mds-border-default); padding: 0.4rem 0.8rem; border-radius: 4px; font-size: 0.8rem; cursor: pointer;">
                        Reset to Defaults
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Chart -->
        <div class="chart-container" style="margin: 2rem 0;">
            <h2 class="chart-title">Advanced Booking Simulation - Uptake Curve</h2>
            <p class="chart-subtitle">Multi-Channel Model ‚Ä¢ Capacity Constraints ‚Ä¢ Cancellation Economics</p>
            <div style="position: relative; height: 400px; width: 100%;">
                <canvas id="bookingChart"></canvas>
            </div>
        </div>

        <!-- Mini-Charts Dashboard -->
        <div style="margin: 2rem 0;">
            <h3 style="text-align: center; color: var(--mds-text-primary); margin-bottom: 1.5rem;">üìä System Analytics Dashboard</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 1.5rem;">
                
                <!-- Searches & Rejections -->
                <div style="background: var(--mds-bg-secondary); border-radius: 8px; padding: 1rem; border: 1px solid var(--mds-border-default);">
                    <h4 style="margin: 0 0 0.5rem 0; color: var(--mds-text-primary); font-size: 0.9rem; text-align: center;">üîç Searches & Offer Rejections</h4>
                    <div style="position: relative; height: 200px; width: 100%;">
                        <canvas id="searchesChart"></canvas>
                    </div>
                </div>

                <!-- Market vs Channel Price -->
                <div style="background: var(--mds-bg-secondary); border-radius: 8px; padding: 1rem; border: 1px solid var(--mds-border-default);">
                    <h4 style="margin: 0 0 0.5rem 0; color: var(--mds-text-primary); font-size: 0.9rem; text-align: center;">üí∞ Market vs Channel Pricing</h4>
                    <div style="position: relative; height: 200px; width: 100%;">
                        <canvas id="pricingChart"></canvas>
                    </div>
                </div>

                <!-- Remaining Capacity -->
                <div style="background: var(--mds-bg-secondary); border-radius: 8px; padding: 1rem; border: 1px solid var(--mds-border-default);">
                    <h4 style="margin: 0 0 0.5rem 0; color: var(--mds-text-primary); font-size: 0.9rem; text-align: center;">üö¢ Remaining Capacity</h4>
                    <div style="position: relative; height: 200px; width: 100%;">
                        <canvas id="capacityChart"></canvas>
                    </div>
                </div>

                <!-- Booking Conversion -->
                <div style="background: var(--mds-bg-secondary); border-radius: 8px; padding: 1rem; border: 1px solid var(--mds-border-default);">
                    <h4 style="margin: 0 0 0.5rem 0; color: var(--mds-text-primary); font-size: 0.9rem; text-align: center;">üéØ Booking Conversion Rate</h4>
                    <div style="position: relative; height: 200px; width: 100%;">
                        <canvas id="conversionChart"></canvas>
                    </div>
                </div>

                <!-- Cancellations & Revenue -->
                <div style="background: var(--mds-bg-secondary); border-radius: 8px; padding: 1rem; border: 1px solid var(--mds-border-default);">
                    <h4 style="margin: 0 0 0.5rem 0; color: var(--mds-text-primary); font-size: 0.9rem; text-align: center;">üîÑ Cancellations & Revenue</h4>
                    <div style="position: relative; height: 200px; width: 100%;">
                        <canvas id="cancellationChart"></canvas>
                    </div>
                </div>

                <!-- Final Outcome Forecast Panel (Clean Rebuild) -->
                <div style="background: var(--mds-bg-secondary); border-radius: 8px; padding: 1rem; border: 1px solid var(--mds-border-default);">
                    <h4 style="margin: 0 0 1rem 0; color: var(--mds-text-primary); font-size: 0.9rem; text-align: center;">üìä Final Outcome Forecast</h4>
                    
                    <!-- Simple Forecast Display -->
                    <div style="background: var(--mds-bg-tertiary); border-radius: 6px; padding: 1rem; text-align: center;">
                        <div style="color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.5rem;" id="forecastDaysRemaining">Days to Departure: --</div>
                        <div style="color: var(--mds-text-primary); font-size: 1.2rem; font-weight: 700; margin-bottom: 0.5rem;" id="cleanForecastRange">-- to -- FFE</div>
                        <div style="color: var(--maersk-blue); font-size: 1rem; font-weight: 600;" id="cleanMostLikely">Most Likely: --</div>
                        <div style="color: var(--mds-text-warning, #b35a00); font-size: 0.9rem; font-weight: 600; margin-top: 0.5rem; display: none;" id="selloutNotice">‚ö†Ô∏è Forecasted sell-out at <span id="selloutDTD">--</span> DTD</div>
                        <div id="guardrailStatus" style="margin-top: 0.5rem; font-size: 0.9rem; font-weight: 600; color: var(--mds-text-primary);"></div>
                        <div id="priceRecommendation" style="margin-top: 0.75rem; display: grid; grid-template-columns: 1fr auto auto; gap: 0.5rem; align-items: center;">
                            <input type="number" id="recommendedChannelPrice" min="0" max="10000" step="10" 
                                   style="background: var(--mds-bg-primary); color: var(--mds-text-primary); border: 1px solid var(--mds-border-default); border-radius: 4px; padding: 6px; font-size: 14px;" placeholder="Recommended Channel Price" readonly />
                            <button id="applyRecommendedPrice" 
                                    style="background: var(--mds-bg-strong); color: white; border: none; border-radius: 4px; padding: 6px 10px; font-weight: 600; cursor: pointer;">Apply</button>
                            <label style="display:flex; align-items:center; gap: 0.4rem; color: var(--mds-text-secondary); font-size: 0.8rem;">
                                <input type="checkbox" id="autoApplyRecommendedPrice" /> Auto-apply before each turn
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Educational Insights -->
        <div class="insights">
            <div class="insight-card neutral" id="insightCard">
                <h3>üéì Educational Insights</h3>
                <p>Run the simulation to see how different parameters affect booking patterns, revenue, and cancellation behavior. This advanced model demonstrates the complex interactions between pricing, capacity, and customer behavior.</p>
            </div>
        </div>
        
        <!-- Navigation -->
        <div style="text-align: center; margin: 2rem 0;">
            <a href="live-pricing-simple.html" style="display: inline-block; background: var(--mds-bg-strong); color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-weight: 500; margin-right: 1rem;">
                üìä Simple Simulator
            </a>
            <a href="index.html" style="display: inline-block; background: var(--mds-bg-strong); color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-weight: 500;">
                üìà Historical Analysis
            </a>
        </div>
    </div>

    <!-- Simulation Summary Modal -->
    <div id="summaryModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10000; justify-content: center; align-items: center;">
        <div style="background: var(--mds-bg-primary, #1a1a1a); border-radius: 12px; padding: 2rem; max-width: 700px; width: 90%; max-height: 85vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                <h2 style="color: var(--maersk-blue); margin: 0;">üéâ Simulation Complete!</h2>
                <button onclick="closeSummaryModal()" style="background: none; border: none; color: var(--mds-text-secondary); font-size: 1.5rem; cursor: pointer; padding: 0; line-height: 1;">√ó</button>
            </div>
            
            <div style="background: var(--mds-bg-secondary); border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem;">
                <h3 style="color: var(--mds-text-primary); margin: 0 0 1rem 0; font-size: 1.1rem;">üìä Final Results</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div>
                        <div style="color: var(--mds-text-secondary); font-size: 0.85rem;">Final Bookings</div>
                        <div style="color: var(--maersk-blue); font-size: 1.5rem; font-weight: 700;" id="summaryFinalBooking">0 FFE</div>
                    </div>
                    <div>
                        <div style="color: var(--mds-text-secondary); font-size: 0.85rem;">Capacity Utilization</div>
                        <div style="color: var(--maersk-success); font-size: 1.5rem; font-weight: 700;" id="summaryCapacityUtil">0%</div>
                    </div>
                    <div>
                        <div style="color: var(--mds-text-secondary); font-size: 0.85rem;">Total Revenue</div>
                        <div style="color: var(--maersk-warning); font-size: 1.5rem; font-weight: 700;" id="summaryTotalRevenue">$0</div>
                    </div>
                    <div>
                        <div style="color: var(--mds-text-secondary); font-size: 0.85rem;">Revenue per FFE</div>
                        <div style="color: var(--maersk-info); font-size: 1.5rem; font-weight: 700;" id="summaryRevenuePerFFE">$0</div>
                    </div>
                    <div>
                        <div style="color: var(--mds-text-secondary); font-size: 0.85rem;">Total Cancellations</div>
                        <div style="color: var(--maersk-error); font-size: 1.2rem; font-weight: 700;" id="summaryCancellations">0 FFE</div>
                    </div>
                    <div>
                        <div style="color: var(--mds-text-secondary); font-size: 0.85rem;">Avg Pricing Ratio</div>
                        <div style="color: var(--mds-text-primary); font-size: 1.2rem; font-weight: 700;" id="summaryAvgRatio">1.00x</div>
                    </div>
                </div>
            </div>
            
            <div style="background: var(--mds-bg-secondary); border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem;">
                <h3 style="color: var(--mds-text-primary); margin: 0 0 1rem 0; font-size: 1.1rem;">üéõÔ∏è Your Strategy</h3>
                <div id="summaryStrategy" style="color: var(--mds-text-secondary); font-size: 0.9rem; line-height: 1.6;"></div>
            </div>
            
            <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                <button onclick="exportSimulationData()" style="background: var(--maersk-info); color: white; border: none; border-radius: 6px; padding: 0.75rem 1.5rem; font-weight: 600; cursor: pointer; font-size: 1rem;">
                    üì• Export CSV
                </button>
                <button onclick="closeSummaryModal()" style="background: var(--maersk-blue); color: white; border: none; border-radius: 6px; padding: 0.75rem 1.5rem; font-weight: 600; cursor: pointer; font-size: 1rem;">
                    Close
                </button>
            </div>
        </div>
    </div>

    <script>
        // ADVANCED SIMULATOR CONFIGURATION
        const SIMULATOR_CONFIG = {
            // Fixed simulation parameters
            departureDate: "2025-06-30",
            horizonDays: 49,
            baseFFEPerOffer: 0.10,
            offersPerSearch: 1.0,
            
            // Default parameter values
            defaults: {
                capacity: 200,
                marketPrice: 3000,
                channelPrice: 3090,
                elasticity: 1.25,
                bookingConversion: 0.03,
                baseWeekdayVolume: 500,
                rampStart: 28,
                taperStart: 5,
                weekendMultiplier: 0.20,
                cancellationFee: 250,
                feePassThrough: 15,
                cancelCap: 5,
                noCancelInside: 5,
                openWeeksBefore: 4,
                expectedOpenDTD: 28,
                guardrailBuffer: 5,
                marketPriceVolatility: 3,
                searchVolatility: 10
            }
        };

        // TURN-BASED SIMULATION STATE
        const TURN_STATE = {
            currentTurn: 1,
            maxTurns: 7,
            daysPerTurn: 7,
            vesselOpened: false,
            vesselOpenedOnTurn: null,
            simulationData: [],
            cumulativeFFE: 0,
            cumulativeRevenue: 0,
            cumulativeCancellations: 0,
            turnHistory: [],
            currentMarketPrice: 3000, // Track volatile market price
            randomSeed: Math.floor(Math.random() * 10000),
            // Canary Early Warning System
            canaryActive: false,
            canarySignal: null, // 0-1 scale (0 = negative shock, 1 = positive shock)
            shockMagnitude: 0, // percentage adjustment applied
            shockDirection: null // 'upward' or 'downward'
        };

        // UTILITY FUNCTIONS
        function getParameterValue(id) {
            const element = document.getElementById(id);
            return element ? parseFloat(element.value) : SIMULATOR_CONFIG.defaults[id.replace(/([A-Z])/g, (match, letter) => letter.toLowerCase())];
        }

        // Update channel markup display
        function updateChannelMarkupDisplay() {
            const marketPrice = getParameterValue('marketPrice');
            const channelPrice = getParameterValue('channelPrice');
            const markup = marketPrice > 0 ? (((channelPrice - marketPrice) / marketPrice) * 100) : 0;
            
            const markupDisplay = document.getElementById('channelMarkupDisplay');
            if (markupDisplay) {
                markupDisplay.textContent = `Markup: ${markup.toFixed(1)}%`;
                
                // Color coding for markup level
                if (markup < 0) {
                    markupDisplay.style.color = 'var(--maersk-error)'; // Red for discount
                } else if (markup <= 5) {
                    markupDisplay.style.color = 'var(--maersk-success)'; // Green for low markup
                } else if (markup <= 15) {
                    markupDisplay.style.color = 'var(--maersk-warning)'; // Orange for medium markup
                } else {
                    markupDisplay.style.color = 'var(--maersk-error)'; // Red for high markup
                }
            }
        }

        // Input validation with visual feedback
        function validateInput(inputId) {
            const input = document.getElementById(inputId);
            if (!input) return true;
            
            const value = parseFloat(input.value);
            const min = parseFloat(input.getAttribute('min'));
            const max = parseFloat(input.getAttribute('max'));
            
            let isValid = true;
            if (isNaN(value)) {
                isValid = false;
            } else if (!isNaN(min) && value < min) {
                input.value = min;
                isValid = false;
            } else if (!isNaN(max) && value > max) {
                input.value = max;
                isValid = false;
            }
            
            // Visual feedback
            if (!isValid) {
                input.style.borderColor = 'var(--maersk-error, #cc0000)';
                input.style.boxShadow = '0 0 4px rgba(204, 0, 0, 0.3)';
                setTimeout(() => {
                    input.style.borderColor = 'var(--mds-border-default)';
                    input.style.boxShadow = 'none';
                }, 1500);
            }
            
            return isValid;
        }

        // Attach validation to all numeric inputs
        function initializeValidation() {
            const numericInputs = [
                'capacity', 'marketPrice', 'channelPrice', 'bookingConversion', 
                'customSensitivity', 'baseWeekdayVolume', 'rampStart', 'taperStart',
                'weekendMultiplier', 'cancellationFee', 'feePassThrough', 'cancelCap',
                'noCancelInside', 'openWeeksBefore', 'expectedOpenDTD', 'guardrailBuffer',
                'marketPriceVolatility', 'searchVolatility'
            ];
            
            numericInputs.forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('change', function() {
                        validateInput(id);
                    });
                    input.addEventListener('blur', function() {
                        validateInput(id);
                    });
                }
            });
        }

        // Toggle custom sensitivity input
        function toggleCustomSensitivity() {
            const sensitivitySelect = document.getElementById('sensitivity');
            const customSensitivityInput = document.getElementById('customSensitivity');
            
            if (sensitivitySelect.value === 'custom') {
                customSensitivityInput.style.display = 'block';
            } else {
                customSensitivityInput.style.display = 'none';
            }
        }

        // Get current elasticity value from sensitivity dropdown
        function getCurrentElasticity() {
            const sensitivitySelect = document.getElementById('sensitivity');
            const customSensitivityInput = document.getElementById('customSensitivity');
            
            if (sensitivitySelect.value === 'custom') {
                return parseFloat(customSensitivityInput.value) || 1.25;
            } else {
                return parseFloat(sensitivitySelect.value) || 1.25;
            }
        }

        // Simple random number generator (seeded)
        function seededRandom() {
            TURN_STATE.randomSeed = (TURN_STATE.randomSeed * 9301 + 49297) % 233280;
            return TURN_STATE.randomSeed / 233280;
        }

        // Generate random price change based on volatility
        function applyMarketPriceVolatility() {
            const volatility = getParameterValue('marketPriceVolatility') / 100;
            if (volatility <= 0) return;

            // Generate random change: -volatility to +volatility
            const randomChange = (seededRandom() - 0.5) * 2 * volatility;
            const newPrice = TURN_STATE.currentMarketPrice * (1 + randomChange);
            
            // Update both state and UI
            TURN_STATE.currentMarketPrice = Math.round(newPrice);
            document.getElementById('marketPrice').value = TURN_STATE.currentMarketPrice;
            
            // Update markup display since market price changed
            updateChannelMarkupDisplay();
        }

        // Apply search volatility to base search volume
        function applySearchVolatility(baseSearches) {
            const volatility = getParameterValue('searchVolatility') / 100;
            if (volatility <= 0) return baseSearches;

            // Generate random multiplier: 1 ¬± volatility
            const randomMultiplier = 1 + (seededRandom() - 0.5) * 2 * volatility;
            return Math.max(0, Math.round(baseSearches * randomMultiplier));
        }

        // CANARY EARLY WARNING SYSTEM
        function checkCanaryShock() {
            // 12.5% chance of shock per turn (10-15% range midpoint)
            const shockProbability = 0.125;
            const shouldShock = Math.random() < shockProbability;
            
            if (!shouldShock) {
                // Reset canary if no shock this turn
                TURN_STATE.canaryActive = false;
                TURN_STATE.canarySignal = null;
                TURN_STATE.shockMagnitude = 0;
                TURN_STATE.shockDirection = null;
                updateCanaryUI();
                return;
            }
            
            // Determine shock direction (50/50 upward vs downward)
            const isUpward = Math.random() < 0.5;
            TURN_STATE.shockDirection = isUpward ? 'upward' : 'downward';
            
            // Generate shock magnitude (5-10% range)
            const magnitudePercent = 5 + Math.random() * 5; // 5% to 10%
            TURN_STATE.shockMagnitude = magnitudePercent;
            
            // Apply shock to current market price
            if (isUpward) {
                // Upward shock: increase market price
                const multiplier = 1 + (magnitudePercent / 100);
                TURN_STATE.currentMarketPrice *= multiplier;
                // Signal strength: 0.85 to 1.0 (higher magnitude = higher signal)
                TURN_STATE.canarySignal = 0.85 + (magnitudePercent - 5) / 5 * 0.15;
            } else {
                // Downward shock: decrease market price
                const multiplier = 1 - (magnitudePercent / 100);
                TURN_STATE.currentMarketPrice *= multiplier;
                // Signal strength: 0.0 to 0.15 (higher magnitude = lower signal)
                TURN_STATE.canarySignal = 0.15 - (magnitudePercent - 5) / 5 * 0.15;
            }
            
            // Activate canary warning
            TURN_STATE.canaryActive = true;
            
            console.log(`üê¶ CANARY SHOCK DETECTED - Turn ${TURN_STATE.currentTurn}:`, {
                direction: TURN_STATE.shockDirection,
                magnitude: `${magnitudePercent.toFixed(1)}%`,
                signal: TURN_STATE.canarySignal.toFixed(2),
                newMarketPrice: Math.round(TURN_STATE.currentMarketPrice)
            });
            
            // Update UI
            updateCanaryUI();
        }
        
        function updateCanaryUI() {
            const canaryElement = document.getElementById('canaryWarning');
            const canarySignalElement = document.getElementById('canarySignal');
            const canaryDirectionElement = document.getElementById('canaryDirection');
            
            if (!canaryElement) return;
            
            if (TURN_STATE.canaryActive && TURN_STATE.canarySignal !== null) {
                canaryElement.style.display = 'block';
                
                // Update signal value
                if (canarySignalElement) {
                    canarySignalElement.textContent = TURN_STATE.canarySignal.toFixed(2);
                }
                
                // Update direction indicator
                if (canaryDirectionElement) {
                    const isPositive = TURN_STATE.canarySignal > 0.5;
                    canaryDirectionElement.textContent = isPositive ? 'üìà Positive Shock' : 'üìâ Negative Shock';
                    canaryDirectionElement.style.color = isPositive ? 'var(--maersk-success, #119b4d)' : 'var(--maersk-error, #cc0000)';
                }
                
                // Color code the signal based on value
                if (canarySignalElement) {
                    if (TURN_STATE.canarySignal >= 0.7) {
                        canarySignalElement.style.color = 'var(--maersk-success, #119b4d)';
                    } else if (TURN_STATE.canarySignal >= 0.3) {
                        canarySignalElement.style.color = 'var(--maersk-warning, #b35a00)';
                    } else {
                        canarySignalElement.style.color = 'var(--maersk-error, #cc0000)';
                    }
                }
            } else {
                canaryElement.style.display = 'none';
            }
        }

        // TURN-BASED SIMULATION FUNCTIONS
        function simulateTurn() {
            // Prevent execution beyond max turns
            if (TURN_STATE.currentTurn > TURN_STATE.maxTurns) {
                return; // Silently return - button should already be disabled
            }

            // Check for canary shock BEFORE market volatility
            checkCanaryShock();

            // Apply market volatility at start of turn (except first turn)
            if (TURN_STATE.currentTurn > 1) {
                applyMarketPriceVolatility();
            }

            // Auto-apply recommended price if enabled
            const autoApply = document.getElementById('autoApplyRecommendedPrice');
            if (autoApply && autoApply.checked) {
                const recInput = document.getElementById('recommendedChannelPrice');
                const value = parseFloat(recInput && recInput.value ? recInput.value : NaN);
                if (!isNaN(value)) {
                    const field = document.getElementById('channelPrice');
                    if (field) {
                        field.value = String(Math.min(10000, Math.max(0, value)));
                        updateChannelMarkupDisplay();
                    }
                }
            }

            // Calculate day range for this turn
            const startDTD = SIMULATOR_CONFIG.horizonDays - ((TURN_STATE.currentTurn - 1) * TURN_STATE.daysPerTurn);
            const endDTD = Math.max(0, startDTD - TURN_STATE.daysPerTurn + 1);

            // Record current decision state
            const turnDecision = {
                turn: TURN_STATE.currentTurn,
                dayRange: `${startDTD}-${endDTD}`,
                marketPrice: getParameterValue('marketPrice'),
                channelPrice: getParameterValue('channelPrice'),
                bookingConversion: getParameterValue('bookingConversion'),
                elasticity: getParameterValue('elasticity'),
                vesselOpened: TURN_STATE.vesselOpened,
                openedThisTurn: false
            };

            // Run simulation for this turn's days
            const turnData = simulateTurnDays(startDTD, endDTD);
            
            // Update cumulative state
            if (turnData.length > 0) {
                const lastDay = turnData[turnData.length - 1];
                TURN_STATE.cumulativeFFE = lastDay.cumulativeFFE;
                TURN_STATE.cumulativeRevenue = lastDay.cumulativeRevenue;
                TURN_STATE.cumulativeCancellations = lastDay.cumulativeCancellationsFFE;
            }

            // Add turn data to simulation history
            TURN_STATE.simulationData = TURN_STATE.simulationData.concat(turnData);
            TURN_STATE.turnHistory.push(turnDecision);

            // Advance turn
            TURN_STATE.currentTurn++;

            // Update UI
            updateTurnUI();
            updateChartsWithTurnData();

            // Check if simulation is complete
            if (TURN_STATE.currentTurn > TURN_STATE.maxTurns) {
                showSimulationSummary(); // Show summary when complete
                document.getElementById('simulateTurnBtn').textContent = 'üéâ Simulation Complete!';
                document.getElementById('simulateTurnBtn').disabled = true;
                document.getElementById('simulateTurnBtn').style.background = 'var(--maersk-success)';
                document.getElementById('simulateTurnBtn').style.cursor = 'not-allowed';
            }
        }

        function simulateTurnDays(startDTD, endDTD) {
            // Get current parameters
            const capacity = getParameterValue('capacity');
            const marketPrice = TURN_STATE.currentMarketPrice; // Use volatile market price
            const channelPrice = getParameterValue('channelPrice');
            const elasticity = getCurrentElasticity();
            const bookingConversion = getParameterValue('bookingConversion');
            const baseWeekdayVolume = getParameterValue('baseWeekdayVolume');
            const rampStart = getParameterValue('rampStart');
            const taperStart = getParameterValue('taperStart');
            const weekendMultiplier = getParameterValue('weekendMultiplier');
            const cancellationFee = getParameterValue('cancellationFee');
            const feePassThrough = getParameterValue('feePassThrough') / 100;
            const cancelCap = getParameterValue('cancelCap') / 100;
            const noCancelInside = getParameterValue('noCancelInside');

            // Generate date range for this turn
            const departureDate = new Date(SIMULATOR_CONFIG.departureDate);
            const records = [];
            
            // Start with cumulative state from previous turns
            let cumFFE = TURN_STATE.cumulativeFFE;
            let cumRev = TURN_STATE.cumulativeRevenue;
            let cumCxlFFE = TURN_STATE.cumulativeCancellations;
            let cumCxlRev = 0; // Calculate from data if needed

            for (let dtd = startDTD; dtd >= endDTD; dtd--) {
                const currentDate = new Date(departureDate);
                currentDate.setDate(currentDate.getDate() - dtd);
                
                const dow = currentDate.getDay();
                const isWeekend = dow === 0 || dow === 6;
                const dowMult = isWeekend ? weekendMultiplier : 1.0;

                // Vessel opening logic - use turn-based state
                const isOpen = TURN_STATE.vesselOpened;

                // Prices + cancellation fee pass-through
                const mp = marketPrice;
                const cpRaw = channelPrice;
                const cpEff = cpRaw + (feePassThrough * cancellationFee);
                const pricingRatio = cpEff / mp;

                // Demand -> searches (with volatility)
                const weekdayMean = dtdBellCurve(dtd, baseWeekdayVolume, 0.18, 0.35, rampStart, taperStart);
                const meanSearches = Math.max(0.0, weekdayMean * dowMult);
                const searches = applySearchVolatility(Math.round(meanSearches));

                // Capacity at start of day
                const remainingCapacity = Math.max(capacity - cumFFE, 0.0);

                let rejNotOpen = 0, rejSoldOut = 0;
                let offers = 0;
                let bookedFFE = 0.0;
                let revenue = 0.0;
                let adjFFEPerOffer = 0.0;

                if (!isOpen) {
                    rejNotOpen = searches;
                } else if (remainingCapacity <= 0.0) {
                    rejSoldOut = searches;
                } else {
                    // Make offers & book
                    offers = Math.round(SIMULATOR_CONFIG.offersPerSearch * searches);
                    adjFFEPerOffer = bookingConversion * Math.pow(pricingRatio, -elasticity);
                    const expectedFFE = offers * Math.max(adjFFEPerOffer, 0.0);
                    bookedFFE = Math.min(expectedFFE, remainingCapacity);
                    revenue = (mp * pricingRatio) * bookedFFE;
                }

                // Update cumulative BEFORE considering cancellations
                const cumFFEPreCxl = cumFFE + bookedFFE;
                const cumRevPreCxl = cumRev + revenue;

                // Simplified cancellation logic for turn-based simulation
                let cxlFFE = 0.0;
                let cxlRev = 0.0;
                let cancellationValue = 0.0;

                if (dtd >= noCancelInside && cumFFEPreCxl > 0) {
                    const bookedPrice = cumRevPreCxl / Math.max(cumFFEPreCxl, 1e-9);
                    const refPrice = Math.min(mp, cpRaw);
                    cancellationValue = bookedPrice - refPrice - cancellationFee;

                    if (cancellationValue > 0) {
                        const scale = Math.max(cancellationFee, 1e-9);
                        const baseRate = 1.0 - Math.exp(-cancellationValue / scale);
                        const cxlRate = Math.min(cancelCap, baseRate * cancelCap);
                        
                        cxlFFE = Math.min(cumFFEPreCxl * cxlRate, cumFFEPreCxl);
                        cxlRev = cxlFFE * cancellationFee;
                    }
                }

                // Apply cancellations
                const cancelledBookingRevenue = cxlFFE > 0 ? (cxlFFE / Math.max(cumFFEPreCxl, 1e-9)) * cumRevPreCxl : 0;
                cumFFE = cumFFEPreCxl - cxlFFE;
                cumRev = (cumRevPreCxl - cancelledBookingRevenue) + cxlRev;
                cumCxlFFE += cxlFFE;
                cumCxlRev += cxlRev;

                records.push({
                    date: new Date(currentDate),
                    daysToDepature: dtd,
                    dow: dow,
                    isWeekend: isWeekend,
                    isOpen: isOpen,
                    marketPrice: mp,
                    channelPriceRaw: cpRaw,
                    channelPriceEff: cpEff,
                    pricingRatio: pricingRatio,
                    weekdayMeanSearches: weekdayMean,
                    dowMultiplier: dowMult,
                    searches: searches,
                    offers: offers,
                    baseFFEPerOffer: bookingConversion,
                    adjFFEPerOffer: adjFFEPerOffer,
                    bookedFFE: bookedFFE,
                    revenueBookings: revenue,
                    cancellationsFFE: cxlFFE,
                    cancellationValue: cancellationValue,
                    revenueCancellations: cxlRev,
                    cumulativeFFE: cumFFE,
                    cumulativeRevenue: cumRev,
                    cumulativeCancellationsFFE: cumCxlFFE,
                    cumulativeCancellationsRevenue: cumCxlRev,
                    remainingCapacityEnd: Math.max(capacity - cumFFE, 0.0),
                    offerRejectionsNotOpen: rejNotOpen,
                    offerRejectionsSoldOut: rejSoldOut
                });
            }

            return records;
        }

        function openVessel() {
            if (TURN_STATE.vesselOpened) {
                alert('Vessel is already open!');
                return;
            }

            TURN_STATE.vesselOpened = true;
            TURN_STATE.vesselOpenedOnTurn = TURN_STATE.currentTurn;

            // Update UI
            document.getElementById('openVesselBtn').textContent = '‚úÖ Vessel Opened';
            document.getElementById('openVesselBtn').disabled = true;
            document.getElementById('openVesselBtn').style.background = 'var(--mds-bg-strong)';
            document.getElementById('openVesselBtn').style.cursor = 'not-allowed';
            document.getElementById('openingHelp').textContent = `Opened on Turn ${TURN_STATE.currentTurn}`;
            
            // Enhanced vessel status styling
            const statusEl = document.getElementById('vesselStatus');
            statusEl.innerHTML = 'üîì Open';
            statusEl.style.color = 'white';
            statusEl.style.backgroundColor = 'var(--maersk-success, #119b4d)';
            statusEl.style.padding = '4px 12px';
            statusEl.style.borderRadius = '4px';
            statusEl.style.fontWeight = '700';
        }

        function resetSimulation() {
            // Reset turn state
            TURN_STATE.currentTurn = 1;
            TURN_STATE.vesselOpened = false;
            TURN_STATE.vesselOpenedOnTurn = null;
            TURN_STATE.simulationData = [];
            TURN_STATE.cumulativeFFE = 0;
            TURN_STATE.cumulativeRevenue = 0;
            TURN_STATE.cumulativeCancellations = 0;
            TURN_STATE.turnHistory = [];
            TURN_STATE.currentMarketPrice = getParameterValue('marketPrice'); // Reset to base market price
            TURN_STATE.randomSeed = Math.floor(Math.random() * 10000); // New random seed
            
            // Reset canary warning system
            TURN_STATE.canaryActive = false;
            TURN_STATE.canarySignal = null;
            TURN_STATE.shockMagnitude = 0;
            TURN_STATE.shockDirection = null;

            // Reset UI
            updateTurnUI();
            updateCanaryUI(); // Hide canary warning
            
            // Reset vessel opening button
            document.getElementById('openVesselBtn').textContent = 'üîì Open Vessel for Booking';
            document.getElementById('openVesselBtn').disabled = false;
            document.getElementById('openVesselBtn').style.background = 'var(--maersk-success)';
            document.getElementById('openVesselBtn').style.cursor = 'pointer';
            document.getElementById('openingHelp').textContent = 'One-time decision - cannot close after opening';
            
            // Reset vessel status with clean styling
            const statusEl = document.getElementById('vesselStatus');
            statusEl.innerHTML = 'üîí Closed';
            statusEl.style.color = 'var(--mds-text-secondary)';
            statusEl.style.backgroundColor = 'transparent';
            statusEl.style.padding = '0';
            statusEl.style.fontWeight = '600';

            // Reset simulate button
            document.getElementById('simulateTurnBtn').textContent = 'üéØ Simulate Turn';
            document.getElementById('simulateTurnBtn').disabled = false;
            document.getElementById('simulateTurnBtn').style.background = 'var(--maersk-blue)';

            // Clear charts
            if (window.chartInstance) {
                window.chartInstance.data.datasets.forEach(dataset => {
                    dataset.data = [];
                });
                window.chartInstance.update();
            }

            // Clear mini charts
            [window.searchesChart, window.pricingChart, window.capacityChart, window.conversionChart, window.cancellationChart].forEach(chart => {
                if (chart) {
                    chart.data.datasets.forEach(dataset => {
                        dataset.data = [];
                    });
                    chart.update();
                }
            });

            // Reset metrics
            document.getElementById('finalBooking').textContent = '0 FFE';
            document.getElementById('capacityUtilization').textContent = '0% Capacity Utilized';
            document.getElementById('totalRevenue').textContent = '$0';
            document.getElementById('avgPricingRatio').textContent = '1.00x';
            document.getElementById('revenuePerFFE').textContent = '$0';
        }

        function updateTurnUI() {
            document.getElementById('currentTurn').textContent = TURN_STATE.currentTurn;
            
            if (TURN_STATE.currentTurn <= TURN_STATE.maxTurns) {
                const startDTD = SIMULATOR_CONFIG.horizonDays - ((TURN_STATE.currentTurn - 1) * TURN_STATE.daysPerTurn);
                const endDTD = Math.max(0, startDTD - TURN_STATE.daysPerTurn + 1);
                document.getElementById('daysRemaining').textContent = `${startDTD}-${endDTD}`;
            } else {
                document.getElementById('daysRemaining').textContent = 'Complete';
            }
        }

        function updateChartsWithTurnData() {
            if (TURN_STATE.simulationData.length === 0) {
                // If no simulation data, just update forecast
                updateForecast();
                return;
            }

            // Update main chart
            updateChannelMarkupDisplay();
            
            const labels = TURN_STATE.simulationData.map(d => d.daysToDepature);
            const cumulativeFFE = TURN_STATE.simulationData.map(d => d.cumulativeFFE);
            
            // Calculate cumulative searches
            let cumulativeSearches = 0;
            const cumulativeSearchesData = TURN_STATE.simulationData.map(d => {
                cumulativeSearches += d.searches;
                return cumulativeSearches;
            });
            
            const capacity = TURN_STATE.simulationData.map(d => getParameterValue('capacity'));

            // Update main chart with forecast
            if (window.chartInstance) {
                const forecast = generateForecast();
                
                if (forecast) {
                    // Combine actual and forecast data
                    const allLabels = [...labels, ...forecast.labels.filter(l => !labels.includes(l))].sort((a, b) => b - a);
                    
                    // Extend actual data with nulls for forecast period
                    const extendedActualFFE = allLabels.map(dtd => {
                        const actualIndex = labels.indexOf(dtd);
                        return actualIndex >= 0 ? cumulativeFFE[actualIndex] : null;
                    });
                    
                    const extendedActualSearches = allLabels.map(dtd => {
                        const actualIndex = labels.indexOf(dtd);
                        return actualIndex >= 0 ? cumulativeSearchesData[actualIndex] : null;
                    });
                    
                    // Forecast data (null for actual period)
                    const forecastMostLikely = allLabels.map(dtd => {
                        const forecastIndex = forecast.labels.indexOf(dtd);
                        return forecastIndex >= 0 && !labels.includes(dtd) ? forecast.mostLikely[forecastIndex] : null;
                    });
                    
                    const forecastOptimistic = allLabels.map(dtd => {
                        const forecastIndex = forecast.labels.indexOf(dtd);
                        return forecastIndex >= 0 && !labels.includes(dtd) ? forecast.optimistic[forecastIndex] : null;
                    });
                    
                    const forecastPessimistic = allLabels.map(dtd => {
                        const forecastIndex = forecast.labels.indexOf(dtd);
                        return forecastIndex >= 0 && !labels.includes(dtd) ? forecast.pessimistic[forecastIndex] : null;
                    });
                    
                    const extendedCapacity = allLabels.map(() => getParameterValue('capacity'));
                    
                    window.chartInstance.data.labels = allLabels;
                    window.chartInstance.data.datasets[0].data = extendedActualFFE;
                    window.chartInstance.data.datasets[1].data = extendedActualSearches;
                    window.chartInstance.data.datasets[2].data = extendedCapacity;
                    window.chartInstance.data.datasets[3].data = forecastPessimistic;
                    window.chartInstance.data.datasets[4].data = forecastOptimistic;
                    window.chartInstance.data.datasets[5].data = forecastMostLikely;
                } else {
                    // No forecast available - just show actual data
                    window.chartInstance.data.labels = labels;
                    window.chartInstance.data.datasets[0].data = cumulativeFFE;
                    window.chartInstance.data.datasets[1].data = cumulativeSearchesData;
                    window.chartInstance.data.datasets[2].data = capacity;
                    window.chartInstance.data.datasets[3].data = [];
                    window.chartInstance.data.datasets[4].data = [];
                    window.chartInstance.data.datasets[5].data = [];
                }
                
                window.chartInstance.update();
            }

            // Update mini-charts
            updateMiniCharts(TURN_STATE.simulationData);

            // Update metrics panel
            updateMetricsPanel(TURN_STATE.simulationData);

            // Update forecast for next turn
            updateForecast();
        }

        // Generate forecast for remaining turns
        function generateForecast() {
            // Get current parameters
            const capacity = getParameterValue('capacity');
            const marketPrice = TURN_STATE.currentMarketPrice || getParameterValue('marketPrice');
            const channelPrice = getParameterValue('channelPrice');
            const elasticity = getCurrentElasticity();
            const bookingConversion = getParameterValue('bookingConversion');
            const baseWeekdayVolume = getParameterValue('baseWeekdayVolume');
            const rampStart = getParameterValue('rampStart');
            const taperStart = getParameterValue('taperStart');
            const weekendMultiplier = getParameterValue('weekendMultiplier');
            const cancellationFee = getParameterValue('cancellationFee');
            const feePassThrough = getParameterValue('feePassThrough') / 100;
            const cancelCap = getParameterValue('cancelCap') / 100;
            const noCancelInside = getParameterValue('noCancelInside');
            const expectedOpenDTD = getParameterValue('expectedOpenDTD');

            // Calculate starting point for forecast
            const currentDTD = SIMULATOR_CONFIG.horizonDays - ((TURN_STATE.currentTurn - 1) * TURN_STATE.daysPerTurn);
            
            // Generate baseline forecast from current turn forward
            const forecastData = [];
            let cumFFE = TURN_STATE.cumulativeFFE;
            let cumRev = TURN_STATE.cumulativeRevenue;
            let cumCxlFFE = TURN_STATE.cumulativeCancellations;

            console.log('DEBUG generateForecast start:', {
                currentTurn: TURN_STATE.currentTurn,
                currentDTD,
                startingCumFFE: cumFFE,
                vesselOpened: TURN_STATE.vesselOpened
            });

            for (let dtd = currentDTD; dtd >= 0; dtd--) {
                const currentDate = new Date(new Date(SIMULATOR_CONFIG.departureDate).getTime() - dtd * 24 * 60 * 60 * 1000);
                const dow = currentDate.getDay();
                const isWeekend = dow === 0 || dow === 6;
                const dowMult = isWeekend ? weekendMultiplier : 1.0;

                // Use current vessel state OR expected opening for forecast
                const isOpen = TURN_STATE.vesselOpened || (dtd <= expectedOpenDTD);

                // Pricing
                const mp = marketPrice;
                const cpRaw = channelPrice;
                const cpEff = cpRaw + (feePassThrough * cancellationFee);
                const pricingRatio = cpEff / mp;

                // Demand
                const weekdayMean = dtdBellCurve(dtd, baseWeekdayVolume, 0.18, 0.35, rampStart, taperStart);
                const meanSearches = Math.max(0.0, weekdayMean * dowMult);
                const searches = Math.round(meanSearches);

                // Capacity
                const remainingCapacity = Math.max(capacity - cumFFE, 0.0);

                let bookedFFE = 0.0;
                let revenue = 0.0;

                if (isOpen && remainingCapacity > 0.0) {
                    const offers = Math.round(SIMULATOR_CONFIG.offersPerSearch * searches);
                    const adjFFEPerOffer = bookingConversion * Math.pow(pricingRatio, -elasticity);
                    const expectedFFE = offers * Math.max(adjFFEPerOffer, 0.0);
                    bookedFFE = Math.min(expectedFFE, remainingCapacity);
                    revenue = (mp * pricingRatio) * bookedFFE;
                }

                // Simplified cancellation
                const cumFFEPreCxl = cumFFE + bookedFFE;
                let cxlFFE = 0.0;
                if (dtd >= noCancelInside && cumFFEPreCxl > 0) {
                    const bookedPrice = (cumRev + revenue) / Math.max(cumFFEPreCxl, 1e-9);
                    const refPrice = Math.min(mp, cpRaw);
                    const cancellationValue = bookedPrice - refPrice - cancellationFee;
                    if (cancellationValue > 0) {
                        const scale = Math.max(cancellationFee, 1e-9);
                        const baseRate = 1.0 - Math.exp(-cancellationValue / scale);
                        const cxlRate = Math.min(cancelCap, baseRate * cancelCap);
                        cxlFFE = Math.min(cumFFEPreCxl * cxlRate, cumFFEPreCxl);
                    }
                }

                cumFFE = cumFFEPreCxl - cxlFFE;
                cumRev += revenue + (cxlFFE * cancellationFee);
                cumCxlFFE += cxlFFE;

                forecastData.push({
                    dtd: dtd,
                    cumulativeFFE: cumFFE,
                    searches: searches,
                    bookedFFE: bookedFFE
                });
            }

            // Find sell-out DTD on most-likely path (first dtd where cumulative >= capacity)
            let selloutDTD = null;
            for (let i = 0; i < forecastData.length; i++) {
                if (forecastData[i].cumulativeFFE >= capacity) {
                    selloutDTD = forecastData[i].dtd;
                    break;
                }
            }

            // Generate uncertainty bands
            const baseVariance = 0.05; // 5% base uncertainty
            const varianceGrowth = 0.02; // 2% additional per turn ahead
            
            const optimisticData = [];
            const pessimisticData = [];
            
            forecastData.forEach((point, index) => {
                const turnsAhead = Math.floor((currentDTD - point.dtd) / TURN_STATE.daysPerTurn) + 1;
                const uncertaintyFactor = baseVariance + varianceGrowth * turnsAhead;
                
                const optimisticValue = Math.min(capacity, point.cumulativeFFE * (1 + uncertaintyFactor));
                const pessimisticValue = Math.max(0, point.cumulativeFFE * (1 - uncertaintyFactor));
                
                optimisticData.push(optimisticValue);
                pessimisticData.push(pessimisticValue);
            });

            const result = {
                labels: forecastData.map(d => d.dtd),
                mostLikely: forecastData.map(d => d.cumulativeFFE),
                optimistic: optimisticData,
                pessimistic: pessimisticData,
                finalForecast: {
                    mostLikely: forecastData[forecastData.length - 1]?.cumulativeFFE || 0,
                    optimistic: optimisticData[optimisticData.length - 1] || 0,
                    pessimistic: pessimisticData[pessimisticData.length - 1] || 0,
                    selloutDTD
                }
            };
            
            console.log('DEBUG generateForecast result:', {
                forecastDataLength: forecastData.length,
                finalForecast: result.finalForecast,
                currentTurn: TURN_STATE.currentTurn,
                cumulativeFFE: TURN_STATE.cumulativeFFE
            });
            
            return result;
        }

        // Clean, simple forecast update
        function updateForecast() {
            const forecast = generateForecast();
            if (!forecast || !forecast.finalForecast) {
                console.log('DEBUG: No valid forecast generated');
                return;
            }

            // Get clean values
            const mostLikely = Math.round(forecast.finalForecast.mostLikely || 0);
            const optimistic = Math.round(forecast.finalForecast.optimistic || 0);
            const pessimistic = Math.round(forecast.finalForecast.pessimistic || 0);
            const selloutDTD = forecast.finalForecast.selloutDTD;
            
            console.log('DEBUG clean forecast update:', { mostLikely, optimistic, pessimistic, selloutDTD });

            // Update summary bar (if elements exist)
            const projectedFinalEl = document.getElementById('projectedFinal');
            const projectedRangeEl = document.getElementById('projectedRange');
            const capacityUtilForecastEl = document.getElementById('capacityUtilForecast');
            
            if (projectedFinalEl) projectedFinalEl.textContent = `${mostLikely} FFE`;
            if (projectedRangeEl) projectedRangeEl.textContent = `${pessimistic} to ${optimistic} FFE`;
            if (capacityUtilForecastEl) {
                const capacity = getParameterValue('capacity');
                capacityUtilForecastEl.textContent = `${Math.round((mostLikely / capacity) * 100)}%`;
            }

            // Update clean forecast panel
            updateCleanForecastPanel(mostLikely, optimistic, pessimistic, selloutDTD);

            // Compute recommendation for channel price
            const recommended = computeRecommendedChannelPrice(forecast);
            const recInput = document.getElementById('recommendedChannelPrice');
            if (recInput) {
                recInput.value = Math.round(recommended);
            }
        }
        // Compute a channel price that targets most-likely == capacity at DTD 0.
        // We approximate by inverting the conversion-power law at the final day.
        function computeRecommendedChannelPrice(forecast) {
            try {
                const capacity = getParameterValue('capacity');
                const marketPrice = TURN_STATE.currentMarketPrice || getParameterValue('marketPrice');
                const elasticity = getCurrentElasticity();
                const bookingConversion = getParameterValue('bookingConversion');
                const cancellationFee = getParameterValue('cancellationFee');
                const feePassThrough = getParameterValue('feePassThrough') / 100;

                // Use last step demand context
                const lastIdx = forecast.labels.length - 1;
                if (lastIdx < 0) return getParameterValue('channelPrice');

                const finalCum = forecast.finalForecast.mostLikely || 0;
                const remainingToTarget = Math.max(capacity - finalCum, 0);

                // If we already sell out early or exactly meet capacity, keep current price
                if (remainingToTarget === 0) return getParameterValue('channelPrice');

                // Estimate additional FFE needed on last day equivalent basis
                // Pull a rough scale from previous step bookings if available
                const mostLikelySeries = forecast.mostLikely;
                const prevCum = mostLikelySeries.length > 1 ? mostLikelySeries[mostLikelySeries.length - 2] : finalCum;
                const recentIncrement = Math.max(finalCum - prevCum, 1e-6);

                // Current pricing ratio and effective channel price
                const currentCP = getParameterValue('channelPrice');
                const cpEffCurrent = currentCP + feePassThrough * cancellationFee;
                const ratioCurrent = cpEffCurrent / Math.max(marketPrice, 1e-6);

                // Conversion follows bookingConversion * ratio^-elasticity.
                // If we need scaleFactor = remainingToTarget / recentIncrement more at the end,
                // we solve for ratio_new such that (ratio_new / ratio_current)^-elasticity = scaleFactor.
                const scaleFactor = Math.max(remainingToTarget / recentIncrement, 1);
                const ratioNew = ratioCurrent * Math.pow(scaleFactor, 1 / elasticity);
                const cpEffNew = ratioNew * marketPrice;
                const cpRawNew = Math.max(0, cpEffNew - feePassThrough * cancellationFee);

                // Clamp to UI bounds
                return Math.min(10000, Math.max(0, cpRawNew));
            } catch (e) {
                console.warn('computeRecommendedChannelPrice failed', e);
                return getParameterValue('channelPrice');
            }
        }

        // Wire up Apply and Auto-apply
        document.addEventListener('DOMContentLoaded', () => {
            const applyBtn = document.getElementById('applyRecommendedPrice');
            if (applyBtn) {
                applyBtn.addEventListener('click', () => {
                    const recInput = document.getElementById('recommendedChannelPrice');
                    const value = parseFloat(recInput && recInput.value ? recInput.value : NaN);
                    if (!isNaN(value)) {
                        const field = document.getElementById('channelPrice');
                        if (field) {
                            field.value = String(Math.min(10000, Math.max(0, value)));
                            
                            // Visual feedback: highlight the updated field
                            field.style.backgroundColor = 'rgba(0, 170, 136, 0.2)';
                            field.style.borderColor = 'var(--maersk-success)';
                            field.style.transition = 'all 0.3s ease';
                            
                            setTimeout(() => {
                                field.style.backgroundColor = 'var(--mds-bg-primary)';
                                field.style.borderColor = 'var(--mds-border-default)';
                            }, 1500);
                            
                            updateChannelMarkupDisplay();
                            updateChartsWithTurnData();
                            
                            // Flash the apply button to confirm action
                            applyBtn.style.backgroundColor = 'var(--maersk-success)';
                            applyBtn.textContent = '‚úì Applied!';
                            setTimeout(() => {
                                applyBtn.style.backgroundColor = 'var(--mds-bg-strong)';
                                applyBtn.textContent = 'Apply';
                            }, 1500);
                        }
                    }
                });
            }
        });

        // Simple, clean forecast panel update
        function updateCleanForecastPanel(mostLikely, optimistic, pessimistic, selloutDTD) {
            const cleanRangeEl = document.getElementById('cleanForecastRange');
            const cleanMostLikelyEl = document.getElementById('cleanMostLikely');
            const selloutNoticeEl = document.getElementById('selloutNotice');
            const selloutDTDEl = document.getElementById('selloutDTD');
            const guardrailStatusEl = document.getElementById('guardrailStatus');
            const forecastDaysEl = document.getElementById('forecastDaysRemaining');
            
            console.log('DEBUG updating clean panel with:', { mostLikely, optimistic, pessimistic });
            
            // Update days remaining display
            if (forecastDaysEl) {
                if (TURN_STATE.currentTurn <= TURN_STATE.maxTurns) {
                    const startDTD = SIMULATOR_CONFIG.horizonDays - ((TURN_STATE.currentTurn - 1) * TURN_STATE.daysPerTurn);
                    const endDTD = Math.max(0, startDTD - TURN_STATE.daysPerTurn + 1);
                    forecastDaysEl.textContent = `Days to Departure: ${startDTD} to ${endDTD}`;
                } else {
                    forecastDaysEl.textContent = `Days to Departure: 0 (Complete)`;
                }
            }
            
            if (cleanRangeEl) {
                cleanRangeEl.textContent = `${pessimistic} - ${optimistic} FFE`;
                console.log('DEBUG set range to:', `${pessimistic} - ${optimistic} FFE`);
            } else {
                console.log('DEBUG: cleanForecastRange element not found');
            }
            
            if (cleanMostLikelyEl) {
                cleanMostLikelyEl.textContent = `Most Likely: ${mostLikely}`;
                console.log('DEBUG set most likely to:', `Most Likely: ${mostLikely}`);
            } else {
                console.log('DEBUG: cleanMostLikely element not found');
            }

            // Show sell-out notice only when most-likely hits capacity and sellout is in the future
            const capacity = getParameterValue('capacity');
            const currentStartDTD = SIMULATOR_CONFIG.horizonDays - ((TURN_STATE.currentTurn - 1) * TURN_STATE.daysPerTurn);
            if (selloutNoticeEl && selloutDTDEl) {
                if (Math.round(mostLikely) >= Math.round(capacity) && selloutDTD !== null && selloutDTD !== undefined && selloutDTD < currentStartDTD) {
                    selloutDTDEl.textContent = `${selloutDTD}`;
                    selloutNoticeEl.style.display = 'block';
                } else {
                    selloutNoticeEl.style.display = 'none';
                }
            }

            // Guardrail-based signal (green/yellow/red)
            if (guardrailStatusEl) {
                const bufferPct = getParameterValue('guardrailBuffer');
                const lower = capacity * (1 - bufferPct / 100);
                const upper = capacity * (1 + bufferPct / 100);
                guardrailStatusEl.textContent = '';
                guardrailStatusEl.style.color = 'var(--mds-text-primary)';
                // Only show sell-out risk if it's in the future (less than current DTD)
                if (Math.round(mostLikely) >= Math.round(capacity) && selloutDTD !== null && selloutDTD > 0 && selloutDTD < currentStartDTD) {
                    guardrailStatusEl.textContent = `üü† Early sell-out risk at ${selloutDTD} DTD`;
                    guardrailStatusEl.style.color = 'var(--maersk-warning, #b35a00)';
                } else if (mostLikely < lower) {
                    guardrailStatusEl.textContent = `üî¥ Below target: ${Math.round(mostLikely)} vs ${capacity}`;
                    guardrailStatusEl.style.color = 'var(--maersk-danger, #cc0000)';
                } else if (mostLikely > upper) {
                    guardrailStatusEl.textContent = `üü° Above target: ${Math.round(mostLikely)} vs ${capacity}`;
                    guardrailStatusEl.style.color = 'var(--maersk-warning, #b35a00)';
                } else {
                    guardrailStatusEl.textContent = `üü¢ On target`;
                    guardrailStatusEl.style.color = 'var(--maersk-success, #119b4d)';
                }
            }
        }

        // Clean, simple forecast update
        function updateForecast() {
            const forecast = generateForecast();
            if (!forecast || !forecast.finalForecast) {
                console.log('DEBUG: No valid forecast generated');
                return;
            }

            // Get clean values
            const mostLikely = Math.round(forecast.finalForecast.mostLikely || 0);
            const optimistic = Math.round(forecast.finalForecast.optimistic || 0);
            const pessimistic = Math.round(forecast.finalForecast.pessimistic || 0);
            const selloutDTD = forecast.finalForecast.selloutDTD;
            
            console.log('DEBUG clean forecast update:', { mostLikely, optimistic, pessimistic, selloutDTD });

            // Update summary bar (if elements exist)
            const projectedFinalEl = document.getElementById('projectedFinal');
            const projectedRangeEl = document.getElementById('projectedRange');
            const capacityUtilForecastEl = document.getElementById('capacityUtilForecast');
            
            if (projectedFinalEl) projectedFinalEl.textContent = `${mostLikely} FFE`;
            if (projectedRangeEl) projectedRangeEl.textContent = `${pessimistic} to ${optimistic} FFE`;
            if (capacityUtilForecastEl) {
                const capacity = getParameterValue('capacity');
                capacityUtilForecastEl.textContent = `${Math.round((mostLikely / capacity) * 100)}%`;
            }

            // Update clean forecast panel
            updateCleanForecastPanel(mostLikely, optimistic, pessimistic, selloutDTD);
        }


        // DTD Bell Curve - JavaScript implementation of your Python function
        function dtdBellCurve(dtd, baseWeekdayVolume = 1000, kRamp = 0.20, kTaper = 0.35, rampStart = 28, taperStart = 5) {
            const D = Math.max(parseInt(dtd), 0);
            const s1 = 1.0 / (1.0 + Math.exp(-kRamp * (rampStart - D)));   // ramps UP after ~28
            const s2 = 1.0 / (1.0 + Math.exp(-kTaper * (D - taperStart))); // tapers DOWN inside ~5
            return baseWeekdayVolume * s1 * s2;
        }

        // Main simulation function - JavaScript implementation of your Python simulator
        function simulateDeparture() {
            // Get parameters from UI
            const capacity = getParameterValue('capacity');
            const marketPrice = getParameterValue('marketPrice');
            const channelPrice = getParameterValue('channelPrice');
            const elasticity = getCurrentElasticity();
            const bookingConversion = getParameterValue('bookingConversion');
            const baseWeekdayVolume = getParameterValue('baseWeekdayVolume');
            const rampStart = getParameterValue('rampStart');
            const taperStart = getParameterValue('taperStart');
            const weekendMultiplier = getParameterValue('weekendMultiplier');
            const cancellationFee = getParameterValue('cancellationFee');
            const feePassThrough = getParameterValue('feePassThrough') / 100;
            const cancelCap = getParameterValue('cancelCap') / 100;
            const noCancelInside = getParameterValue('noCancelInside');
            const openWeeksBefore = getParameterValue('openWeeksBefore');

            // Generate date range (49 days to departure)
            const departureDate = new Date(SIMULATOR_CONFIG.departureDate);
            const startDate = new Date(departureDate);
            startDate.setDate(startDate.getDate() - SIMULATOR_CONFIG.horizonDays);
            
            const records = [];
            let cumFFE = 0.0;
            let cumRev = 0.0;
            let cumCxlFFE = 0.0;
            let cumCxlRev = 0.0;

            // Opening policy check
            const openingDate = new Date(departureDate);
            openingDate.setDate(openingDate.getDate() - (openWeeksBefore * 7));

            for (let i = 0; i <= SIMULATOR_CONFIG.horizonDays; i++) {
                const currentDate = new Date(startDate);
                currentDate.setDate(currentDate.getDate() + i);
                
                const dtd = Math.floor((departureDate - currentDate) / (1000 * 60 * 60 * 24));
                const dow = currentDate.getDay(); // 0 = Sunday, 6 = Saturday
                const isWeekend = dow === 0 || dow === 6;
                const dowMult = isWeekend ? weekendMultiplier : 1.0;

                // Opening state
                const isOpen = currentDate >= openingDate;

                // Prices + cancellation fee pass-through
                const mp = marketPrice;
                const cpRaw = channelPrice;
                const cpEff = cpRaw + (feePassThrough * cancellationFee);
                const pricingRatio = cpEff / mp;

                // Demand -> searches
                const weekdayMean = dtdBellCurve(dtd, baseWeekdayVolume, 0.18, 0.35, rampStart, taperStart);
                const meanSearches = Math.max(0.0, weekdayMean * dowMult);
                const searches = Math.round(meanSearches);

                // Capacity at start of day
                const remainingCapacity = Math.max(capacity - cumFFE, 0.0);

                let rejNotOpen = 0, rejSoldOut = 0;
                let offers = 0;
                let bookedFFE = 0.0;
                let revenue = 0.0;
                let adjFFEPerOffer = 0.0;

                if (!isOpen) {
                    rejNotOpen = searches;
                } else if (remainingCapacity <= 0.0) {
                    rejSoldOut = searches;
                } else {
                    // Make offers & book
                    offers = Math.round(SIMULATOR_CONFIG.offersPerSearch * searches);
                    adjFFEPerOffer = bookingConversion * Math.pow(pricingRatio, -elasticity);
                    const expectedFFE = offers * Math.max(adjFFEPerOffer, 0.0);
                    bookedFFE = Math.min(expectedFFE, remainingCapacity);
                    revenue = (mp * pricingRatio) * bookedFFE;
                }

                // Update cumulative BEFORE considering cancellations
                const cumFFEPreCxl = cumFFE + bookedFFE;
                const cumRevPreCxl = cumRev + revenue;

                // Cancellations
                let cxlFFE = 0.0;
                let cxlRev = 0.0;
                let cancellationValue = 0.0;

                if (dtd >= noCancelInside && cumFFEPreCxl > 0) {
                    const bookedPrice = cumRevPreCxl / Math.max(cumFFEPreCxl, 1e-9);
                    const refPrice = Math.min(mp, cpRaw);
                    cancellationValue = bookedPrice - refPrice - cancellationFee;

                    if (cancellationValue > 0) {
                        const scale = Math.max(cancellationFee, 1e-9);
                        const baseRate = 1.0 - Math.exp(-cancellationValue / scale);
                        const cxlRate = Math.min(cancelCap, baseRate * cancelCap);
                        
                        cxlFFE = Math.min(cumFFEPreCxl * cxlRate, cumFFEPreCxl);
                        cxlRev = cxlFFE * cancellationFee;
                    }
                }

                // Apply cancellations to cumulative state
                cumFFE = cumFFEPreCxl - cxlFFE;
                // Revenue calculation: keep booking revenue, add cancellation fee revenue
                // Don't double-count the original booking revenue for cancelled FFE
                const cancelledBookingRevenue = cxlFFE > 0 ? (cxlFFE / Math.max(cumFFEPreCxl, 1e-9)) * cumRevPreCxl : 0;
                cumRev = (cumRevPreCxl - cancelledBookingRevenue) + cxlRev;
                cumCxlFFE += cxlFFE;
                cumCxlRev += cxlRev;

                records.push({
                    date: new Date(currentDate),
                    daysToDepature: dtd,
                    dow: dow,
                    isWeekend: isWeekend,
                    isOpen: isOpen,
                    marketPrice: mp,
                    channelPriceRaw: cpRaw,
                    channelPriceEff: cpEff,
                    pricingRatio: pricingRatio,
                    weekdayMeanSearches: weekdayMean,
                    dowMultiplier: dowMult,
                    searches: searches,
                    offers: offers,
                    baseFFEPerOffer: bookingConversion,
                    adjFFEPerOffer: adjFFEPerOffer,
                    bookedFFE: bookedFFE,
                    revenueBookings: revenue,
                    cancellationsFFE: cxlFFE,
                    cancellationValue: cancellationValue,
                    revenueCancellations: cxlRev,
                    cumulativeFFE: cumFFE,
                    cumulativeRevenue: cumRev,
                    cumulativeCancellationsFFE: cumCxlFFE,
                    cumulativeCancellationsRevenue: cumCxlRev,
                    remainingCapacityEnd: Math.max(capacity - cumFFE, 0.0),
                    offerRejectionsNotOpen: rejNotOpen,
                    offerRejectionsSoldOut: rejSoldOut
                });
            }

            return records;
        }

        // Chart initialization and update
        function initChart() {
            const ctx = document.getElementById('bookingChart');
            if (!ctx) return;

            if (window.chartInstance) {
                window.chartInstance.destroy();
            }

            window.chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Cumulative FFE Booked',
                            data: [],
                            borderColor: 'rgb(66, 176, 213)',
                            backgroundColor: 'rgba(66, 176, 213, 0.1)',
                            borderWidth: 3,
                            pointRadius: 4,
                            pointBackgroundColor: 'rgb(66, 176, 213)',
                            fill: true,
                            tension: 0.3
                        },
                        {
                            label: 'Cumulative Searches',
                            data: [],
                            borderColor: 'rgba(138, 138, 138, 0.7)',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 2,
                            fill: false,
                            tension: 0.3,
                            borderDash: [5, 5],
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Capacity',
                            data: [],
                            borderColor: 'rgb(229, 62, 62)',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false,
                            tension: 0,
                            borderDash: [10, 5]
                        },
                        {
                            label: 'Forecast - Pessimistic',
                            data: [],
                            borderColor: 'rgba(255, 99, 71, 0.8)', // Brighter red-orange
                            backgroundColor: 'rgba(255, 99, 71, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.3,
                            borderDash: [2, 4] // Short dashes
                        },
                        {
                            label: 'Forecast - Optimistic',
                            data: [],
                            borderColor: 'rgba(50, 205, 50, 0.8)', // Brighter lime green
                            backgroundColor: 'rgba(50, 205, 50, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: '-1',
                            tension: 0.3,
                            borderDash: [8, 4] // Long dashes
                        },
                        {
                            label: 'Forecast - Most Likely',
                            data: [],
                            borderColor: 'rgba(255, 215, 0, 0.9)', // Bright gold
                            backgroundColor: 'transparent',
                            borderWidth: 2.5,
                            pointRadius: 2,
                            fill: false,
                            tension: 0.3,
                            borderDash: [12, 6] // Very long dashes
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Days to Departure',
                                font: { size: 14, weight: '600' },
                                color: 'rgb(212, 212, 212)'
                            },
                            reverse: false, // 49 DTD on left, 0 DTD on right
                            grid: {
                                color: 'rgba(138, 138, 138, 0.3)'
                            },
                            ticks: {
                                color: 'rgb(138, 138, 138)',
                                font: { size: 11 },
                                maxRotation: 45,
                                minRotation: 45,
                                maxTicksLimit: 12,
                                autoSkip: true
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Cumulative FFE',
                                font: { size: 14, weight: '600' },
                                color: 'rgb(212, 212, 212)'
                            },
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(138, 138, 138, 0.3)'
                            },
                            ticks: {
                                color: 'rgb(138, 138, 138)',
                                font: { size: 12 }
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Cumulative Searches',
                                font: { size: 12, weight: '600' },
                                color: 'rgb(180, 180, 180)'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                            ticks: {
                                color: 'rgb(138, 138, 138)',
                                font: { size: 10 }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                color: 'rgb(212, 212, 212)',
                                font: { size: 11, weight: '500' },
                                padding: 12,
                                usePointStyle: true
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(33, 33, 33, 0.95)',
                            titleColor: 'rgb(240, 240, 240)',
                            bodyColor: 'rgb(212, 212, 212)',
                            borderColor: 'rgb(76, 76, 76)',
                            borderWidth: 1,
                            cornerRadius: 8,
                            padding: 12
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }


        // Initialize mini-charts
        function initMiniCharts() {
            // Common chart options for mini-charts
            const miniChartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        display: true,
                        grid: { color: 'rgba(138, 138, 138, 0.2)' },
                        ticks: { 
                            color: 'rgb(138, 138, 138)', 
                            font: { size: 9 },
                            maxTicksLimit: 8,
                            maxRotation: 45,
                            minRotation: 0,
                            autoSkip: true
                        }
                    },
                    y: {
                        display: true,
                        beginAtZero: true,
                        grid: { color: 'rgba(138, 138, 138, 0.2)' },
                        ticks: { 
                            color: 'rgb(138, 138, 138)', 
                            font: { size: 10 }
                        }
                    }
                },
                plugins: {
                    legend: { 
                        display: true,
                        position: 'bottom',
                        labels: {
                            color: 'rgb(212, 212, 212)',
                            font: { size: 9 },
                            padding: 8,
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(33, 33, 33, 0.95)',
                        titleColor: 'rgb(240, 240, 240)',
                        bodyColor: 'rgb(212, 212, 212)',
                        borderColor: 'rgb(76, 76, 76)',
                        borderWidth: 1,
                        cornerRadius: 6,
                        padding: 8,
                        titleFont: { size: 11 },
                        bodyFont: { size: 10 }
                    }
                },
                interaction: { intersect: false, mode: 'index' }
            };

            // 1. Searches & Rejections Chart (Cumulative with Stacked Rejection Areas)
            const searchesCtx = document.getElementById('searchesChart');
            if (searchesCtx) {
                window.searchesChart = new Chart(searchesCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Cumulative Rejected (Not Open)',
                                data: [],
                                backgroundColor: 'rgba(255, 165, 0, 0.7)',
                                borderColor: 'rgb(255, 165, 0)',
                                borderWidth: 1,
                                pointRadius: 1,
                                fill: 'origin',
                                tension: 0.3
                            },
                            {
                                label: 'Cumulative Rejected (Sold Out)',
                                data: [],
                                backgroundColor: 'rgba(229, 62, 62, 0.7)',
                                borderColor: 'rgb(229, 62, 62)',
                                borderWidth: 1,
                                pointRadius: 1,
                                fill: '-1',
                                tension: 0.3
                            },
                            {
                                label: 'Cumulative Searches',
                                data: [],
                                backgroundColor: 'transparent',
                                borderColor: 'rgba(138, 138, 138, 0.8)',
                                borderWidth: 2,
                                pointRadius: 2,
                                fill: false,
                                tension: 0.3,
                                borderDash: [4, 4]
                            }
                        ]
                    },
                    options: {
                        ...miniChartOptions,
                        scales: {
                            ...miniChartOptions.scales,
                            y: {
                                ...miniChartOptions.scales.y,
                                title: { display: true, text: 'Cumulative Volume', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            },
                            x: {
                                ...miniChartOptions.scales.x,
                                title: { display: true, text: 'DTD', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            }
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            ...miniChartOptions.plugins,
                            tooltip: {
                                ...miniChartOptions.plugins.tooltip,
                                mode: 'index',
                                intersect: false
                            }
                        }
                    }
                });
            }

            // 2. Market vs Channel Pricing Chart
            const pricingCtx = document.getElementById('pricingChart');
            if (pricingCtx) {
                window.pricingChart = new Chart(pricingCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Market Price',
                                data: [],
                                borderColor: 'rgb(255, 180, 50)',
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                pointRadius: 2,
                                tension: 0.1
                            },
                            {
                                label: 'Channel Price (Raw)',
                                data: [],
                                borderColor: 'rgb(66, 176, 213)',
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                pointRadius: 2,
                                tension: 0.1
                            },
                            {
                                label: 'Channel Price (w/ Fees)',
                                data: [],
                                borderColor: 'rgb(138, 43, 226)',
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                pointRadius: 2,
                                tension: 0.1,
                                borderDash: [4, 4]
                            }
                        ]
                    },
                    options: {
                        ...miniChartOptions,
                        scales: {
                            ...miniChartOptions.scales,
                            y: {
                                ...miniChartOptions.scales.y,
                                beginAtZero: false, // Don't start at zero - focus on actual price range
                                title: { display: true, text: 'Price ($)', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            },
                            x: {
                                ...miniChartOptions.scales.x,
                                title: { display: true, text: 'DTD', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            }
                        }
                    }
                });
            }

            // 3. Remaining Capacity Chart
            const capacityCtx = document.getElementById('capacityChart');
            if (capacityCtx) {
                window.capacityChart = new Chart(capacityCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Remaining Capacity',
                                data: [],
                                borderColor: 'rgb(229, 62, 62)',
                                backgroundColor: 'rgba(229, 62, 62, 0.1)',
                                borderWidth: 2,
                                pointRadius: 2,
                                fill: true,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        ...miniChartOptions,
                        scales: {
                            ...miniChartOptions.scales,
                            y: {
                                ...miniChartOptions.scales.y,
                                title: { display: true, text: 'FFE', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            },
                            x: {
                                ...miniChartOptions.scales.x,
                                title: { display: true, text: 'DTD', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            }
                        }
                    }
                });
            }

            // 4. Booking Conversion Chart
            const conversionCtx = document.getElementById('conversionChart');
            if (conversionCtx) {
                window.conversionChart = new Chart(conversionCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Base Conversion Rate',
                                data: [],
                                borderColor: 'rgba(138, 138, 138, 0.6)',
                                backgroundColor: 'transparent',
                                borderWidth: 1,
                                pointRadius: 1,
                                tension: 0.1,
                                borderDash: [3, 3]
                            },
                            {
                                label: 'Adjusted Conversion Rate',
                                data: [],
                                borderColor: 'rgb(0, 170, 136)',
                                backgroundColor: 'rgba(0, 170, 136, 0.1)',
                                borderWidth: 2,
                                pointRadius: 2,
                                fill: true,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        ...miniChartOptions,
                        scales: {
                            ...miniChartOptions.scales,
                            y: {
                                ...miniChartOptions.scales.y,
                                title: { display: true, text: 'Rate', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            },
                            x: {
                                ...miniChartOptions.scales.x,
                                title: { display: true, text: 'DTD', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            }
                        }
                    }
                });
            }

            // 5. Cancellations & Revenue Chart
            const cancellationCtx = document.getElementById('cancellationChart');
            if (cancellationCtx) {
                window.cancellationChart = new Chart(cancellationCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Cumulative Cancellations (FFE)',
                                data: [],
                                backgroundColor: 'rgba(255, 165, 0, 0.7)',
                                borderColor: 'rgb(255, 165, 0)',
                                borderWidth: 2,
                                pointRadius: 2,
                                fill: true,
                                tension: 0.3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Cumulative Cancellation Revenue ($)',
                                data: [],
                                type: 'line',
                                borderColor: 'rgb(0, 170, 136)',
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                pointRadius: 2,
                                tension: 0.3,
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        ...miniChartOptions,
                        scales: {
                            x: {
                                ...miniChartOptions.scales.x,
                                title: { display: true, text: 'DTD', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            },
                            y: {
                                ...miniChartOptions.scales.y,
                                title: { display: true, text: 'FFE', color: 'rgb(180, 180, 180)', font: { size: 10 } },
                                position: 'left'
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: { display: true, text: 'Revenue ($)', color: 'rgb(180, 180, 180)', font: { size: 10 } },
                                grid: { drawOnChartArea: false },
                                ticks: { 
                                    color: 'rgb(138, 138, 138)', 
                                    font: { size: 10 }
                                }
                            }
                        }
                    }
                });
            }
        }


        // Update mini-charts with simulation data
        function updateMiniCharts(data) {
            const labels = data.map(d => d.daysToDepature);

            // 1. Update Searches & Rejections Chart (Cumulative)
            if (window.searchesChart) {
                let cumulativeRejectedNotOpen = 0;
                let cumulativeRejectedSoldOut = 0;
                let cumulativeSearches = 0;

                // Calculate cumulative rejections with proper logic
                const cumulativeNotOpenData = [];
                const cumulativeSoldOutData = [];
                const cumulativeSearchesData = [];

                data.forEach(d => {
                    // Always accumulate total searches
                    cumulativeSearches += d.searches;
                    cumulativeSearchesData.push(cumulativeSearches);

                    // Only accumulate rejections that actually happened
                    // (the simulation already has the correct logic)
                    cumulativeRejectedNotOpen += d.offerRejectionsNotOpen;
                    cumulativeRejectedSoldOut += d.offerRejectionsSoldOut;

                    // Store cumulative values for chart
                    cumulativeNotOpenData.push(cumulativeRejectedNotOpen);
                    cumulativeSoldOutData.push(cumulativeRejectedNotOpen + cumulativeRejectedSoldOut);
                });

                window.searchesChart.data.labels = labels;
                window.searchesChart.data.datasets[0].data = cumulativeNotOpenData;
                window.searchesChart.data.datasets[1].data = cumulativeSoldOutData;
                window.searchesChart.data.datasets[2].data = cumulativeSearchesData;
                window.searchesChart.update('none');
            }

            // 2. Update Market vs Channel Pricing Chart
            if (window.pricingChart) {
                const marketPrices = data.map(d => d.marketPrice);
                const channelPricesRaw = data.map(d => d.channelPriceRaw);
                const channelPricesEff = data.map(d => d.channelPriceEff);

                window.pricingChart.data.labels = labels;
                window.pricingChart.data.datasets[0].data = marketPrices;
                window.pricingChart.data.datasets[1].data = channelPricesRaw;
                window.pricingChart.data.datasets[2].data = channelPricesEff;
                window.pricingChart.update('none');
            }

            // 3. Update Remaining Capacity Chart
            if (window.capacityChart) {
                const remainingCapacity = data.map(d => d.remainingCapacityEnd);

                window.capacityChart.data.labels = labels;
                window.capacityChart.data.datasets[0].data = remainingCapacity;
                window.capacityChart.update('none');
            }

            // 4. Update Booking Conversion Chart
            if (window.conversionChart) {
                const baseConversion = data.map(d => d.baseFFEPerOffer);
                const adjustedConversion = data.map(d => d.adjFFEPerOffer);

                window.conversionChart.data.labels = labels;
                window.conversionChart.data.datasets[0].data = baseConversion;
                window.conversionChart.data.datasets[1].data = adjustedConversion;
                window.conversionChart.update('none');
            }

            // 5. Update Cancellations & Revenue Chart
            if (window.cancellationChart) {
                // Calculate cumulative cancellations
                let cumulativeCancellations = 0;
                const cumulativeCancellationsData = data.map(d => {
                    cumulativeCancellations += d.cancellationsFFE;
                    return cumulativeCancellations;
                });

                // Calculate cumulative cancellation revenue
                let cumulativeCancellationRevenue = 0;
                const cumulativeCancellationRevenueData = data.map(d => {
                    cumulativeCancellationRevenue += d.revenueCancellations;
                    return cumulativeCancellationRevenue;
                });

                window.cancellationChart.data.labels = labels;
                window.cancellationChart.data.datasets[0].data = cumulativeCancellationsData;
                window.cancellationChart.data.datasets[1].data = cumulativeCancellationRevenueData;
                window.cancellationChart.update('none');
            }
        }

        // Update metrics panel
        function updateMetricsPanel(data) {
            if (!data || data.length === 0) {
                // Reset to default values if no data
                document.getElementById('finalBooking').textContent = '0 FFE';
                document.getElementById('capacityUtilization').textContent = '0% Capacity Utilized';
                document.getElementById('totalRevenue').textContent = '$0';
                document.getElementById('totalCancellations').textContent = '0 FFE';
                document.getElementById('avgPricingRatio').textContent = '1.00x';
                document.getElementById('revenuePerFFE').textContent = '$0';
                return;
            }
            
            const finalRecord = data[data.length - 1];
            const capacity = getParameterValue('capacity');
            
            // Calculate metrics
            const finalBooking = finalRecord.cumulativeFFE;
            const capacityUtil = (finalBooking / capacity * 100).toFixed(1);
            const totalRevenue = finalRecord.cumulativeRevenue;
            const cancellationRevenue = finalRecord.cumulativeCancellationsRevenue;
            // Calculate booking revenue as total minus cancellation fees
            const bookingRevenue = totalRevenue - cancellationRevenue;
            const totalCancellations = finalRecord.cumulativeCancellationsFFE;
            const cancelRate = ((totalCancellations / Math.max(finalBooking + totalCancellations, 1)) * 100).toFixed(1);
            
            // Calculate average pricing ratio (weighted by bookings)
            let totalWeightedRatio = 0;
            let totalBookings = 0;
            data.forEach(d => {
                if (d.bookedFFE > 0) {
                    totalWeightedRatio += d.pricingRatio * d.bookedFFE;
                    totalBookings += d.bookedFFE;
                }
            });
            const avgPricingRatio = totalBookings > 0 ? (totalWeightedRatio / totalBookings).toFixed(2) : "1.00";
            const revenuePerFFE = finalBooking > 0 ? (totalRevenue / finalBooking).toFixed(0) : "0";

            // Update UI (only elements that exist in compact layout)
            const finalBookingEl = document.getElementById('finalBooking');
            const capacityUtilizationEl = document.getElementById('capacityUtilization');
            const totalRevenueEl = document.getElementById('totalRevenue');
            const totalCancellationsEl = document.getElementById('totalCancellations');
            const avgPricingRatioEl = document.getElementById('avgPricingRatio');
            const revenuePerFFEEl = document.getElementById('revenuePerFFE');
            
            if (finalBookingEl) finalBookingEl.textContent = `${Math.round(finalBooking)} FFE`;
            if (capacityUtilizationEl) capacityUtilizationEl.textContent = `${capacityUtil}% Capacity Utilized`;
            if (totalRevenueEl) totalRevenueEl.textContent = `$${Math.round(totalRevenue).toLocaleString()}`;
            if (totalCancellationsEl) totalCancellationsEl.textContent = `${Math.round(totalCancellations)} FFE`;
            if (avgPricingRatioEl) avgPricingRatioEl.textContent = `${avgPricingRatio}x`;
            if (revenuePerFFEEl) revenuePerFFEEl.textContent = `$${revenuePerFFE}`;
            
            // Update additional elements if they exist (for backwards compatibility)
            const bookingRevenueEl = document.getElementById('bookingRevenue');
            const cancellationRevenueEl = document.getElementById('cancellationRevenue');
            const cancelRateEl = document.getElementById('cancellationRate');
            
            if (bookingRevenueEl) bookingRevenueEl.textContent = `$${Math.round(bookingRevenue).toLocaleString()}`;
            if (cancellationRevenueEl) cancellationRevenueEl.textContent = `$${Math.round(cancellationRevenue).toLocaleString()}`;
            if (cancelRateEl) cancelRateEl.textContent = `${cancelRate}%`;
        }


        // Show simulation summary modal
        function showSimulationSummary() {
            if (!TURN_STATE.simulationData || TURN_STATE.simulationData.length === 0) return;
            
            const finalRecord = TURN_STATE.simulationData[TURN_STATE.simulationData.length - 1];
            const capacity = getParameterValue('capacity');
            
            // Calculate metrics
            const finalBooking = finalRecord.cumulativeFFE;
            const capacityUtil = (finalBooking / capacity * 100).toFixed(1);
            const totalRevenue = finalRecord.cumulativeRevenue;
            const cancellationRevenue = finalRecord.cumulativeCancellationsRevenue || 0;
            const bookingRevenue = totalRevenue - cancellationRevenue;
            const totalCancellations = finalRecord.cumulativeCancellationsFFE;
            const revenuePerFFE = finalBooking > 0 ? (bookingRevenue / finalBooking).toFixed(0) : 0;
            
            // Calculate average pricing ratio
            let totalWeightedRatio = 0;
            let totalBookings = 0;
            TURN_STATE.simulationData.forEach(d => {
                if (d.bookedFFE > 0) {
                    totalWeightedRatio += d.pricingRatio * d.bookedFFE;
                    totalBookings += d.bookedFFE;
                }
            });
            const avgPricingRatio = totalBookings > 0 ? (totalWeightedRatio / totalBookings).toFixed(2) : "1.00";
            
            // Update summary modal
            document.getElementById('summaryFinalBooking').textContent = `${Math.round(finalBooking)} FFE`;
            document.getElementById('summaryCapacityUtil').textContent = `${capacityUtil}%`;
            document.getElementById('summaryTotalRevenue').textContent = `$${Math.round(totalRevenue).toLocaleString()}`;
            document.getElementById('summaryRevenuePerFFE').textContent = `$${revenuePerFFE}`;
            document.getElementById('summaryCancellations').textContent = `${Math.round(totalCancellations)} FFE`;
            document.getElementById('summaryAvgRatio').textContent = `${avgPricingRatio}x`;
            
            // Build strategy summary
            const vesselOpenedTurn = TURN_STATE.turnHistory.findIndex(t => t.vesselOpened && !TURN_STATE.turnHistory[Math.max(0, TURN_STATE.turnHistory.indexOf(t) - 1)]?.vesselOpened) + 1;
            let strategyHTML = `<ul style="margin: 0; padding-left: 1.5rem;">`;
            strategyHTML += `<li><strong>Vessel opened:</strong> Turn ${vesselOpenedTurn > 0 ? vesselOpenedTurn : 'Never'}</li>`;
            strategyHTML += `<li><strong>Price range:</strong> $${Math.min(...TURN_STATE.simulationData.map(d => d.channelPriceRaw))} - $${Math.max(...TURN_STATE.simulationData.map(d => d.channelPriceRaw))}</li>`;
            strategyHTML += `<li><strong>Capacity target:</strong> ${capacity} FFE</li>`;
            strategyHTML += `<li><strong>Final outcome:</strong> ${finalBooking > capacity * 0.95 ? 'üü¢ Near full capacity' : finalBooking > capacity * 0.8 ? 'üü° Good fill' : 'üî¥ Under-filled'}</li>`;
            strategyHTML += `</ul>`;
            document.getElementById('summaryStrategy').innerHTML = strategyHTML;
            
            // Show modal
            const modal = document.getElementById('summaryModal');
            if (modal) {
                modal.style.display = 'flex';
            }
        }
        
        function closeSummaryModal() {
            const modal = document.getElementById('summaryModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Export simulation data as CSV
        function exportSimulationData() {
            if (!TURN_STATE.simulationData || TURN_STATE.simulationData.length === 0) {
                alert('No simulation data to export');
                return;
            }
            
            // CSV headers
            let csv = 'Date,DTD,Market Price,Channel Price (Raw),Channel Price (Eff),Pricing Ratio,Searches,Offers,Booked FFE,Cumulative FFE,Cancellations FFE,Remaining Capacity,Revenue,Cumulative Revenue\n';
            
            // Add data rows
            TURN_STATE.simulationData.forEach(d => {
                csv += `${d.date},${d.dtd},${d.marketPrice},${d.channelPriceRaw},${d.channelPriceEff},${d.pricingRatio.toFixed(3)},${d.searches},${d.offers},${d.bookedFFE.toFixed(2)},${d.cumulativeFFE.toFixed(2)},${d.cancellationsFFE.toFixed(2)},${d.remainingCapacityEnd.toFixed(2)},${d.revenue.toFixed(2)},${d.cumulativeRevenue.toFixed(2)}\n`;
            });
            
            // Create download link
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `booking-simulation-${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // UI Controls
        function toggleAdvancedParams() {
            const content = document.getElementById('advancedContent');
            const arrow = document.getElementById('advancedArrow');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(180deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        function resetParameters() {
            Object.keys(SIMULATOR_CONFIG.defaults).forEach(key => {
                const element = document.getElementById(key);
                if (element) {
                    element.value = SIMULATOR_CONFIG.defaults[key];
                }
            });
            runSimulation();
        }
        
        function resetAllParameters() {
            // Reset all advanced parameters
            Object.keys(SIMULATOR_CONFIG.defaults).forEach(key => {
                const element = document.getElementById(key);
                if (element) {
                    element.value = SIMULATOR_CONFIG.defaults[key];
                }
            });
            
            // Reset core parameters to their default values
            const coreDefaults = {
                capacity: 200,
                marketPrice: 3000,
                channelPrice: 3090,
                bookingConversion: 0.03,
                sensitivity: '1.25',
                customSensitivity: 1.25
            };
            
            Object.keys(coreDefaults).forEach(key => {
                const element = document.getElementById(key);
                if (element) {
                    element.value = coreDefaults[key];
                }
            });
            
            // Update UI
            updateChannelMarkupDisplay();
            updateChartsWithTurnData();
            
            // Visual feedback
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '‚úì Parameters Reset!';
            btn.style.backgroundColor = 'var(--maersk-success)';
            btn.style.color = 'white';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.backgroundColor = 'var(--mds-bg-strong)';
                btn.style.color = 'var(--mds-text-secondary)';
            }, 1500);
        }

        // Initialize on page load
        window.addEventListener('load', function() {
            initChart();
            initMiniCharts();
            initializeValidation(); // Set up input validation
            updateTurnUI();
            updateChannelMarkupDisplay();
            updateForecast(); // Show initial forecast
        });

        // Mark todo as complete
        console.log("‚úÖ Advanced simulator implementation complete");
    </script>
</body>
</html>
