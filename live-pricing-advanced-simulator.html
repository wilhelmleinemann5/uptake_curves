<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced FFE Booking Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script src="styles/chart-config.js"></script>
    <link rel="stylesheet" href="styles/maersk-theme.css">
</head>
<body>
    <header class="header">
        <h1>üö¢ Advanced Booking Simulator</h1>
        <p>Sophisticated Multi-Channel FFE Booking Model with Cancellations & Capacity</p>
    </header>

    <div class="container">
        <div class="demo-note">
            <h3>‚ö° Advanced Simulator - Jun 30 Departure</h3>
            <p>Experience a realistic booking system with search patterns, pricing ratios, cancellation economics, and capacity constraints. Adjust parameters to see how different strategies affect the uptake curve.</p>
        </div>
        
        <!-- Turn-Based Simulation Controls -->
        <div style="background: var(--mds-bg-secondary); padding: 1rem; border-radius: 8px; margin: 1.5rem 0; border: 2px solid var(--maersk-blue);">
            <h4 style="text-align: center; margin: 0 0 1rem 0; color: var(--mds-text-primary);">üéÆ Turn-Based Simulator</h4>
            
            <!-- Turn Status -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding: 0.8rem; background: var(--mds-bg-tertiary); border-radius: 6px;">
                <div>
                    <span style="color: var(--mds-text-secondary); font-size: 0.9rem;">Current Turn:</span>
                    <span style="color: var(--maersk-blue); font-weight: 700; font-size: 1.2rem; margin-left: 0.5rem;" id="currentTurn">1</span>
                    <span style="color: var(--mds-text-secondary); font-size: 0.9rem; margin-left: 0.5rem;">of 7</span>
                </div>
                <div>
                    <span style="color: var(--mds-text-secondary); font-size: 0.9rem;">Days Remaining:</span>
                    <span style="color: var(--maersk-warning); font-weight: 700; font-size: 1.2rem; margin-left: 0.5rem;" id="daysRemaining">49-43</span>
                </div>
                <div>
                    <span style="color: var(--mds-text-secondary); font-size: 0.9rem;">Vessel Status:</span>
                    <span style="font-weight: 600; margin-left: 0.5rem;" id="vesselStatus">üîí Closed</span>
                </div>
            </div>

            <!-- Forecast Summary -->
            <div style="margin-bottom: 1rem; padding: 0.8rem; background: var(--mds-bg-tertiary); border-radius: 6px; border: 1px solid var(--mds-border-default);">
                <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem;">
                    <div>
                        <span style="color: var(--mds-text-secondary);">üîÆ Projected Final:</span>
                        <span id="projectedFinal" style="color: var(--maersk-blue); font-weight: 600; margin-left: 0.5rem;">-- FFE</span>
                    </div>
                    <div>
                        <span style="color: var(--mds-text-secondary);">Range:</span>
                        <span id="projectedRange" style="color: var(--mds-text-primary); font-weight: 500; margin-left: 0.5rem;">-- to -- FFE</span>
                    </div>
                    <div>
                        <span style="color: var(--mds-text-secondary);">Capacity:</span>
                        <span id="capacityUtilForecast" style="color: var(--maersk-warning); font-weight: 600; margin-left: 0.5rem;">--%</span>
                    </div>
                </div>
            </div>

            <!-- Turn Controls -->
            <div style="display: flex; gap: 1rem; justify-content: center; align-items: center; margin-bottom: 1rem;">
                <button id="simulateTurnBtn" onclick="simulateTurn()" 
                        style="background: var(--maersk-blue); color: white; border: none; padding: 0.8rem 2rem; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                    üéØ Simulate Turn
                </button>
                <button onclick="resetSimulation()" 
                        style="background: var(--mds-bg-strong); color: var(--mds-text-secondary); border: 1px solid var(--mds-border-default); padding: 0.8rem 1.5rem; border-radius: 6px; font-size: 0.9rem; cursor: pointer;">
                    üîÑ Reset Simulation
                </button>
            </div>
        </div>

        <!-- Core Parameters Panel -->
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin: 1.5rem 0; background: var(--mds-bg-secondary); padding: 1rem; border-radius: 8px;">
            <h4 style="grid-column: 1 / -1; text-align: center; margin: 0 0 1rem 0; color: var(--mds-text-primary);">üéõÔ∏è Decision Parameters (Adjust Each Turn)</h4>
            
            <!-- Capacity -->
            <div style="background: var(--mds-bg-tertiary); padding: 12px; border-radius: 6px; border-left: 3px solid var(--maersk-blue);">
                <label for="capacity" style="display: block; font-weight: 600; margin-bottom: 4px;">üö¢ Capacity (FFE):</label>
                <input type="number" id="capacity" value="200" min="50" max="500" step="10" 
                       style="width: 100%; background: var(--mds-bg-primary); color: var(--mds-text-primary); border: 1px solid var(--mds-border-default); border-radius: 4px; padding: 6px; font-size: 14px;">
            </div>
            
            <!-- Market Price -->
            <div style="background: var(--mds-bg-tertiary); padding: 12px; border-radius: 6px; border-left: 3px solid var(--maersk-warning);">
                <label for="marketPrice" style="display: block; font-weight: 600; margin-bottom: 4px;">üí∞ Market Price ($):</label>
                <input type="number" id="marketPrice" value="3000" min="2000" max="5000" step="50" 
                       style="width: 100%; background: var(--mds-bg-primary); color: var(--mds-text-primary); border: 1px solid var(--mds-border-default); border-radius: 4px; padding: 6px; font-size: 14px;"
                       oninput="updateChannelMarkupDisplay(); updateChartsWithTurnData()">
            </div>
            
            <!-- Channel Price -->
            <div style="background: var(--mds-bg-tertiary); padding: 12px; border-radius: 6px; border-left: 3px solid var(--maersk-info);">
                <label for="channelPrice" style="display: block; font-weight: 600; margin-bottom: 4px;">üìä Channel Price ($):</label>
                <input type="number" id="channelPrice" value="3090" min="2000" max="6000" step="10" 
                       style="width: 100%; background: var(--mds-bg-primary); color: var(--mds-text-primary); border: 1px solid var(--mds-border-default); border-radius: 4px; padding: 6px; font-size: 14px;"
                       oninput="updateChannelMarkupDisplay(); updateChartsWithTurnData()">
                <div style="color: var(--mds-text-weak); font-size: 0.7rem; margin-top: 0.25rem;" id="channelMarkupDisplay">
                    Markup: 3.0%
                </div>
            </div>
            
            <!-- Price Sensitivity -->
            <div style="background: var(--mds-bg-tertiary); padding: 12px; border-radius: 6px; border-left: 3px solid var(--maersk-success);">
                <label for="sensitivity" style="display: block; font-weight: 600; margin-bottom: 4px;">üìà Price Sensitivity:</label>
                <select id="sensitivity" 
                        style="width: 100%; background: var(--mds-bg-primary); color: var(--mds-text-primary); border: 1px solid var(--mds-border-default); border-radius: 4px; padding: 6px; font-size: 14px;"
                        onchange="toggleCustomSensitivity(); updateChartsWithTurnData()">
                    <option value="0.5">üìà Conservative</option>
                    <option value="1.0">üéØ Balanced</option>
                    <option value="1.25" selected>‚ö° Moderate</option>
                    <option value="2.0">üî• Aggressive</option>
                    <option value="3.0">üí• Extreme</option>
                    <option value="custom">üßÆ Custom</option>
                </select>
                <input type="number" id="customSensitivity" value="1.25" min="0.1" max="5.0" step="0.1" 
                       style="width: 100%; background: var(--mds-bg-primary); color: var(--mds-text-primary); border: 1px solid var(--mds-border-default); border-radius: 4px; padding: 6px; font-size: 14px; margin-top: 4px; display: none;"
                       oninput="updateChartsWithTurnData()">
            </div>
            
            <!-- Booking Conversion -->
            <div style="background: var(--mds-bg-tertiary); padding: 12px; border-radius: 6px; border-left: 3px solid var(--maersk-light-blue);">
                <label for="bookingConversion" style="display: block; font-weight: 600; margin-bottom: 4px;">üéØ Booking Conversion:</label>
                <input type="number" id="bookingConversion" value="0.03" min="0.01" max="0.50" step="0.01" 
                       style="width: 100%; background: var(--mds-bg-primary); color: var(--mds-text-primary); border: 1px solid var(--mds-border-default); border-radius: 4px; padding: 6px; font-size: 14px;"
                       oninput="updateChartsWithTurnData()">
                <div style="color: var(--mds-text-weak); font-size: 0.7rem; margin-top: 0.25rem;">
                    FFE per offer (base rate)
                </div>
            </div>

            <!-- Vessel Opening Decision -->
            <div style="background: var(--mds-bg-tertiary); padding: 12px; border-radius: 6px; border-left: 3px solid var(--maersk-success);">
                <label style="display: block; font-weight: 600; margin-bottom: 8px;">üö¢ Vessel Opening:</label>
                <button id="openVesselBtn" onclick="openVessel()" 
                        style="width: 100%; background: var(--maersk-success); color: white; border: none; padding: 8px; border-radius: 4px; font-size: 14px; font-weight: 600; cursor: pointer;">
                    üîì Open Vessel for Booking
                </button>
                <div style="color: var(--mds-text-weak); font-size: 0.7rem; margin-top: 0.25rem;" id="openingHelp">
                    One-time decision - cannot close after opening
                </div>
            </div>
        </div>
        
        <!-- Advanced Parameters (Collapsible) -->
        <div style="margin: 1rem 0; padding: 1rem; background: var(--mds-bg-secondary); border-radius: 8px; border: 1px solid var(--mds-border-default);">
            <div style="text-align: center; cursor: pointer; user-select: none;" onclick="toggleAdvancedParams()" id="advancedToggle">
                <span style="color: var(--mds-text-secondary); font-size: 0.9rem; font-weight: 500;">
                    ‚öôÔ∏è Advanced Parameters
                    <span id="advancedArrow" style="margin-left: 0.5rem; transition: transform 0.3s ease;">‚ñº</span>
                </span>
            </div>
            
            <div id="advancedContent" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--mds-border-default);">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                    
                    <!-- Demand Curve Parameters -->
                    <div style="grid-column: 1 / -1; color: var(--mds-text-secondary); font-size: 0.9rem; font-weight: 600; margin-bottom: 0.5rem;">
                        üìä Demand Curve Parameters
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Base Weekday Volume</label>
                        <input type="number" id="baseWeekdayVolume" value="500" min="200" max="2000" step="50" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Ramp Start (DTD)</label>
                        <input type="number" id="rampStart" value="28" min="20" max="40" step="1" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Taper Start (DTD)</label>
                        <input type="number" id="taperStart" value="5" min="2" max="10" step="1" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Weekend Multiplier</label>
                        <input type="number" id="weekendMultiplier" value="0.20" min="0.01" max="0.8" step="0.05" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <!-- Cancellation Parameters -->
                    <div style="grid-column: 1 / -1; color: var(--mds-text-secondary); font-size: 0.9rem; font-weight: 600; margin: 1rem 0 0.5rem 0;">
                        üîÑ Cancellation Economics
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Cancellation Fee ($)</label>
                        <input type="number" id="cancellationFee" value="250" min="0" max="500" step="25" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Fee Pass-Through (%)</label>
                        <input type="number" id="feePassThrough" value="15" min="0" max="50" step="5" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Cancel Cap per Day (%)</label>
                        <input type="number" id="cancelCap" value="5" min="1" max="10" step="0.5" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">No Cancel Inside (DTD)</label>
                        <input type="number" id="noCancelInside" value="5" min="0" max="10" step="1" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>
                    
                    <!-- Opening Policy -->
                    <div style="grid-column: 1 / -1; color: var(--mds-text-secondary); font-size: 0.9rem; font-weight: 600; margin: 1rem 0 0.5rem 0;">
                        üìÖ Opening Policy
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Open Weeks Before</label>
                        <input type="number" id="openWeeksBefore" value="4" min="1" max="12" step="1" 
                               onchange="runSimulation()"
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                    </div>

                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Expected Open Date (DTD)</label>
                        <input type="number" id="expectedOpenDTD" value="28" min="5" max="45" step="1" 
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                        <div style="color: var(--mds-text-weak); font-size: 0.7rem; margin-top: 0.25rem;">
                            For forecast calculations only
                        </div>
                    </div>

                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Target Guardrail Buffer (%)</label>
                        <input type="number" id="guardrailBuffer" value="5" min="1" max="20" step="1" 
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                        <div style="color: var(--mds-text-weak); font-size: 0.7rem; margin-top: 0.25rem;">
                            Threshold around capacity target
                        </div>
                    </div>

                    <!-- Market Volatility -->
                    <div style="grid-column: 1 / -1; color: var(--mds-text-secondary); font-size: 0.9rem; font-weight: 600; margin: 1rem 0 0.5rem 0;">
                        üìä Market Volatility
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Market Price Volatility (%)</label>
                        <input type="number" id="marketPriceVolatility" value="3" min="0" max="15" step="0.5" 
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                        <div style="color: var(--mds-text-weak); font-size: 0.7rem; margin-top: 0.25rem;">
                            Random price change per turn
                        </div>
                    </div>
                    
                    <div>
                        <label style="display: block; color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">Search Volume Volatility (%)</label>
                        <input type="number" id="searchVolatility" value="10" min="0" max="30" step="1" 
                               style="width: 100%; padding: 0.4rem; background: var(--mds-bg-tertiary); border: 1px solid var(--mds-border-default); border-radius: 4px; color: var(--mds-text-primary); font-size: 0.85rem;">
                        <div style="color: var(--mds-text-weak); font-size: 0.7rem; margin-top: 0.25rem;">
                            Random search variation
                        </div>
                    </div>
                </div>
                
                <!-- Reset Button -->
                <div style="text-align: center; margin-top: 1rem;">
                    <button onclick="resetParameters()" 
                            style="background: var(--mds-bg-strong); color: var(--mds-text-secondary); border: 1px solid var(--mds-border-default); padding: 0.4rem 0.8rem; border-radius: 4px; font-size: 0.8rem; cursor: pointer;">
                        Reset to Defaults
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Chart -->
        <div class="chart-container" style="margin: 2rem 0;">
            <h2 class="chart-title">Advanced Booking Simulation - Uptake Curve</h2>
            <p class="chart-subtitle">Multi-Channel Model ‚Ä¢ Capacity Constraints ‚Ä¢ Cancellation Economics</p>
            <div style="position: relative; height: 400px; width: 100%;">
                <canvas id="bookingChart"></canvas>
            </div>
        </div>

        <!-- Mini-Charts Dashboard -->
        <div style="margin: 2rem 0;">
            <h3 style="text-align: center; color: var(--mds-text-primary); margin-bottom: 1.5rem;">üìä System Analytics Dashboard</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 1.5rem;">
                
                <!-- Searches & Rejections -->
                <div style="background: var(--mds-bg-secondary); border-radius: 8px; padding: 1rem; border: 1px solid var(--mds-border-default);">
                    <h4 style="margin: 0 0 0.5rem 0; color: var(--mds-text-primary); font-size: 0.9rem; text-align: center;">üîç Searches & Offer Rejections</h4>
                    <div style="position: relative; height: 200px; width: 100%;">
                        <canvas id="searchesChart"></canvas>
                    </div>
                </div>

                <!-- Market vs Channel Price -->
                <div style="background: var(--mds-bg-secondary); border-radius: 8px; padding: 1rem; border: 1px solid var(--mds-border-default);">
                    <h4 style="margin: 0 0 0.5rem 0; color: var(--mds-text-primary); font-size: 0.9rem; text-align: center;">üí∞ Market vs Channel Pricing</h4>
                    <div style="position: relative; height: 200px; width: 100%;">
                        <canvas id="pricingChart"></canvas>
                    </div>
                </div>

                <!-- Remaining Capacity -->
                <div style="background: var(--mds-bg-secondary); border-radius: 8px; padding: 1rem; border: 1px solid var(--mds-border-default);">
                    <h4 style="margin: 0 0 0.5rem 0; color: var(--mds-text-primary); font-size: 0.9rem; text-align: center;">üö¢ Remaining Capacity</h4>
                    <div style="position: relative; height: 200px; width: 100%;">
                        <canvas id="capacityChart"></canvas>
                    </div>
                </div>

                <!-- Booking Conversion -->
                <div style="background: var(--mds-bg-secondary); border-radius: 8px; padding: 1rem; border: 1px solid var(--mds-border-default);">
                    <h4 style="margin: 0 0 0.5rem 0; color: var(--mds-text-primary); font-size: 0.9rem; text-align: center;">üéØ Booking Conversion Rate</h4>
                    <div style="position: relative; height: 200px; width: 100%;">
                        <canvas id="conversionChart"></canvas>
                    </div>
                </div>

                <!-- Cancellations & Revenue -->
                <div style="background: var(--mds-bg-secondary); border-radius: 8px; padding: 1rem; border: 1px solid var(--mds-border-default);">
                    <h4 style="margin: 0 0 0.5rem 0; color: var(--mds-text-primary); font-size: 0.9rem; text-align: center;">üîÑ Cancellations & Revenue</h4>
                    <div style="position: relative; height: 200px; width: 100%;">
                        <canvas id="cancellationChart"></canvas>
                    </div>
                </div>

                <!-- Final Outcome Forecast Panel -->
                <div style="background: var(--mds-bg-secondary); border-radius: 8px; padding: 1rem; border: 1px solid var(--mds-border-default);">
                    <h4 style="margin: 0 0 1rem 0; color: var(--mds-text-primary); font-size: 0.9rem; text-align: center;">üìä Final Outcome Forecast</h4>
                    
                    <!-- Final Forecast -->
                    <div style="background: var(--mds-bg-tertiary); border-radius: 6px; padding: 0.8rem; margin-bottom: 0.8rem;">
                        <div style="text-align: center; margin-bottom: 0.3rem;">
                            <span style="color: var(--mds-text-secondary); font-size: 0.8rem;">Days to Departure: 0</span>
                        </div>
                        <div style="text-align: center; color: var(--mds-text-primary); font-size: 1.1rem; font-weight: 700;" id="forecastRange">-- to -- FFE</div>
                        <div style="text-align: center; color: var(--maersk-blue); font-size: 1rem; font-weight: 600; margin-top: 0.25rem;" id="mostLikelyForecast">Most Likely: --</div>
                    </div>
                    
                    <!-- Target Comparison -->
                    <div style="background: var(--mds-bg-tertiary); border-radius: 6px; padding: 0.8rem; margin-bottom: 0.8rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4rem;">
                            <span style="color: var(--mds-text-secondary); font-size: 0.8rem;">üéØ Target:</span>
                            <span style="color: var(--maersk-success); font-weight: 600;" id="targetValueDisplay">200 FFE</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="color: var(--mds-text-secondary); font-size: 0.8rem;">Gap to Target:</span>
                            <span style="font-weight: 600;" id="targetGap">-- FFE</span>
                        </div>
                    </div>
                    
                    <!-- Guardrails Status -->
                    <div style="background: var(--mds-bg-tertiary); border-radius: 6px; padding: 0.8rem; margin-bottom: 0.8rem;">
                        <div style="text-align: center; margin-bottom: 0.4rem;">
                            <span style="color: var(--mds-text-secondary); font-size: 0.8rem;">Guardrail Status</span>
                        </div>
                        <div style="text-align: center;" id="guardrailStatusPanel">
                            <span style="font-size: 1rem; font-weight: 600;">‚úÖ Within Range</span>
                        </div>
                        <div style="text-align: center; margin-top: 0.4rem; font-size: 0.7rem; color: var(--mds-text-secondary);" id="thresholdRangeDisplay">
                            190 - 210 FFE
                        </div>
                    </div>
                    
                    <!-- Recommendation -->
                    <div style="text-align: center;">
                        <div style="color: var(--mds-text-secondary); font-size: 0.8rem; margin-bottom: 0.4rem;">Recommendation</div>
                        <div style="font-size: 0.85rem; font-weight: 500; margin-bottom: 0.6rem;" id="quickRecommendation">Monitor trajectory</div>
                        
                        <!-- Price Change Recommendation -->
                        <div id="priceChangeRecommendation" style="display: none; margin-bottom: 0.6rem;">
                            <div style="color: var(--mds-text-secondary); font-size: 0.75rem; margin-bottom: 0.2rem;">Recommended Channel Price</div>
                            <div style="font-size: 0.9rem; font-weight: 600; color: var(--maersk-warning);" id="recommendedChannelPrice">$3090</div>
                            <div style="color: var(--mds-text-secondary); font-size: 0.7rem; margin-top: 0.2rem;" id="changeRationale">To reach target forecast</div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div id="actionButtons" style="display: none; gap: 0.6rem; margin-top: 0.8rem; justify-content: center;">
                            <button id="applyRecommendation" onclick="applyRecommendedChannelPrice()" 
                                    style="background: var(--maersk-light-blue); color: white; border: 1px solid var(--maersk-light-blue); padding: 0.5rem 1rem; border-radius: 4px; font-size: 0.8rem; cursor: pointer; font-weight: 600;">
                                Apply Price
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Educational Insights -->
        <div class="insights">
            <div class="insight-card neutral" id="insightCard">
                <h3>üéì Educational Insights</h3>
                <p>Run the simulation to see how different parameters affect booking patterns, revenue, and cancellation behavior. This advanced model demonstrates the complex interactions between pricing, capacity, and customer behavior.</p>
            </div>
        </div>
        
        <!-- Navigation -->
        <div style="text-align: center; margin: 2rem 0;">
            <a href="live-pricing-simple.html" style="display: inline-block; background: var(--mds-bg-strong); color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-weight: 500; margin-right: 1rem;">
                üìä Simple Simulator
            </a>
            <a href="index.html" style="display: inline-block; background: var(--mds-bg-strong); color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-weight: 500;">
                üìà Historical Analysis
            </a>
        </div>
    </div>

    <script>
        // ADVANCED SIMULATOR CONFIGURATION
        const SIMULATOR_CONFIG = {
            // Fixed simulation parameters
            departureDate: "2025-06-30",
            horizonDays: 49,
            baseFFEPerOffer: 0.10,
            offersPerSearch: 1.0,
            
            // Default parameter values
            defaults: {
                capacity: 200,
                marketPrice: 3000,
                channelPrice: 3090,
                elasticity: 1.25,
                bookingConversion: 0.03,
                baseWeekdayVolume: 500,
                rampStart: 28,
                taperStart: 5,
                weekendMultiplier: 0.20,
                cancellationFee: 250,
                feePassThrough: 15,
                cancelCap: 5,
                noCancelInside: 5,
                openWeeksBefore: 4,
                expectedOpenDTD: 28,
                guardrailBuffer: 5,
                marketPriceVolatility: 3,
                searchVolatility: 10
            }
        };

        // TURN-BASED SIMULATION STATE
        const TURN_STATE = {
            currentTurn: 1,
            maxTurns: 7,
            daysPerTurn: 7,
            vesselOpened: false,
            vesselOpenedOnTurn: null,
            simulationData: [],
            cumulativeFFE: 0,
            cumulativeRevenue: 0,
            cumulativeCancellations: 0,
            turnHistory: [],
            currentMarketPrice: 3000, // Track volatile market price
            randomSeed: Math.floor(Math.random() * 10000)
        };

        // UTILITY FUNCTIONS
        function getParameterValue(id) {
            const element = document.getElementById(id);
            return element ? parseFloat(element.value) : SIMULATOR_CONFIG.defaults[id.replace(/([A-Z])/g, (match, letter) => letter.toLowerCase())];
        }

        // Update channel markup display
        function updateChannelMarkupDisplay() {
            const marketPrice = getParameterValue('marketPrice');
            const channelPrice = getParameterValue('channelPrice');
            const markup = marketPrice > 0 ? (((channelPrice - marketPrice) / marketPrice) * 100) : 0;
            
            const markupDisplay = document.getElementById('channelMarkupDisplay');
            if (markupDisplay) {
                markupDisplay.textContent = `Markup: ${markup.toFixed(1)}%`;
                
                // Color coding for markup level
                if (markup < 0) {
                    markupDisplay.style.color = 'var(--maersk-error)'; // Red for discount
                } else if (markup <= 5) {
                    markupDisplay.style.color = 'var(--maersk-success)'; // Green for low markup
                } else if (markup <= 15) {
                    markupDisplay.style.color = 'var(--maersk-warning)'; // Orange for medium markup
                } else {
                    markupDisplay.style.color = 'var(--maersk-error)'; // Red for high markup
                }
            }
        }

        // Toggle custom sensitivity input
        function toggleCustomSensitivity() {
            const sensitivitySelect = document.getElementById('sensitivity');
            const customSensitivityInput = document.getElementById('customSensitivity');
            
            if (sensitivitySelect.value === 'custom') {
                customSensitivityInput.style.display = 'block';
            } else {
                customSensitivityInput.style.display = 'none';
            }
        }

        // Get current elasticity value from sensitivity dropdown
        function getCurrentElasticity() {
            const sensitivitySelect = document.getElementById('sensitivity');
            const customSensitivityInput = document.getElementById('customSensitivity');
            
            if (sensitivitySelect.value === 'custom') {
                return parseFloat(customSensitivityInput.value) || 1.25;
            } else {
                return parseFloat(sensitivitySelect.value) || 1.25;
            }
        }

        // Simple random number generator (seeded)
        function seededRandom() {
            TURN_STATE.randomSeed = (TURN_STATE.randomSeed * 9301 + 49297) % 233280;
            return TURN_STATE.randomSeed / 233280;
        }

        // Generate random price change based on volatility
        function applyMarketPriceVolatility() {
            const volatility = getParameterValue('marketPriceVolatility') / 100;
            if (volatility <= 0) return;

            // Generate random change: -volatility to +volatility
            const randomChange = (seededRandom() - 0.5) * 2 * volatility;
            const newPrice = TURN_STATE.currentMarketPrice * (1 + randomChange);
            
            // Update both state and UI
            TURN_STATE.currentMarketPrice = Math.round(newPrice);
            document.getElementById('marketPrice').value = TURN_STATE.currentMarketPrice;
            
            // Update markup display since market price changed
            updateChannelMarkupDisplay();
        }

        // Apply search volatility to base search volume
        function applySearchVolatility(baseSearches) {
            const volatility = getParameterValue('searchVolatility') / 100;
            if (volatility <= 0) return baseSearches;

            // Generate random multiplier: 1 ¬± volatility
            const randomMultiplier = 1 + (seededRandom() - 0.5) * 2 * volatility;
            return Math.max(0, Math.round(baseSearches * randomMultiplier));
        }

        // TURN-BASED SIMULATION FUNCTIONS
        function simulateTurn() {
            if (TURN_STATE.currentTurn > TURN_STATE.maxTurns) {
                alert('Simulation complete! Use Reset to start over.');
                return;
            }

            // Apply market volatility at start of turn (except first turn)
            if (TURN_STATE.currentTurn > 1) {
                applyMarketPriceVolatility();
            }

            // Calculate day range for this turn
            const startDTD = SIMULATOR_CONFIG.horizonDays - ((TURN_STATE.currentTurn - 1) * TURN_STATE.daysPerTurn);
            const endDTD = Math.max(0, startDTD - TURN_STATE.daysPerTurn + 1);

            // Record current decision state
            const turnDecision = {
                turn: TURN_STATE.currentTurn,
                dayRange: `${startDTD}-${endDTD}`,
                marketPrice: getParameterValue('marketPrice'),
                channelPrice: getParameterValue('channelPrice'),
                bookingConversion: getParameterValue('bookingConversion'),
                elasticity: getParameterValue('elasticity'),
                vesselOpened: TURN_STATE.vesselOpened,
                openedThisTurn: false
            };

            // Run simulation for this turn's days
            const turnData = simulateTurnDays(startDTD, endDTD);
            
            // Update cumulative state
            if (turnData.length > 0) {
                const lastDay = turnData[turnData.length - 1];
                TURN_STATE.cumulativeFFE = lastDay.cumulativeFFE;
                TURN_STATE.cumulativeRevenue = lastDay.cumulativeRevenue;
                TURN_STATE.cumulativeCancellations = lastDay.cumulativeCancellationsFFE;
            }

            // Add turn data to simulation history
            TURN_STATE.simulationData = TURN_STATE.simulationData.concat(turnData);
            TURN_STATE.turnHistory.push(turnDecision);

            // Advance turn
            TURN_STATE.currentTurn++;

            // Update UI
            updateTurnUI();
            updateChartsWithTurnData();

            // Check if simulation is complete
            if (TURN_STATE.currentTurn > TURN_STATE.maxTurns) {
                document.getElementById('simulateTurnBtn').textContent = 'üéâ Simulation Complete!';
                document.getElementById('simulateTurnBtn').disabled = true;
                document.getElementById('simulateTurnBtn').style.background = 'var(--maersk-success)';
            }
        }

        function simulateTurnDays(startDTD, endDTD) {
            // Get current parameters
            const capacity = getParameterValue('capacity');
            const marketPrice = TURN_STATE.currentMarketPrice; // Use volatile market price
            const channelPrice = getParameterValue('channelPrice');
            const elasticity = getCurrentElasticity();
            const bookingConversion = getParameterValue('bookingConversion');
            const baseWeekdayVolume = getParameterValue('baseWeekdayVolume');
            const rampStart = getParameterValue('rampStart');
            const taperStart = getParameterValue('taperStart');
            const weekendMultiplier = getParameterValue('weekendMultiplier');
            const cancellationFee = getParameterValue('cancellationFee');
            const feePassThrough = getParameterValue('feePassThrough') / 100;
            const cancelCap = getParameterValue('cancelCap') / 100;
            const noCancelInside = getParameterValue('noCancelInside');

            // Generate date range for this turn
            const departureDate = new Date(SIMULATOR_CONFIG.departureDate);
            const records = [];
            
            // Start with cumulative state from previous turns
            let cumFFE = TURN_STATE.cumulativeFFE;
            let cumRev = TURN_STATE.cumulativeRevenue;
            let cumCxlFFE = TURN_STATE.cumulativeCancellations;
            let cumCxlRev = 0; // Calculate from data if needed

            for (let dtd = startDTD; dtd >= endDTD; dtd--) {
                const currentDate = new Date(departureDate);
                currentDate.setDate(currentDate.getDate() - dtd);
                
                const dow = currentDate.getDay();
                const isWeekend = dow === 0 || dow === 6;
                const dowMult = isWeekend ? weekendMultiplier : 1.0;

                // Vessel opening logic - use turn-based state
                const isOpen = TURN_STATE.vesselOpened;

                // Prices + cancellation fee pass-through
                const mp = marketPrice;
                const cpRaw = channelPrice;
                const cpEff = cpRaw + (feePassThrough * cancellationFee);
                const pricingRatio = cpEff / mp;

                // Demand -> searches (with volatility)
                const weekdayMean = dtdBellCurve(dtd, baseWeekdayVolume, 0.18, 0.35, rampStart, taperStart);
                const meanSearches = Math.max(0.0, weekdayMean * dowMult);
                const searches = applySearchVolatility(Math.round(meanSearches));

                // Capacity at start of day
                const remainingCapacity = Math.max(capacity - cumFFE, 0.0);

                let rejNotOpen = 0, rejSoldOut = 0;
                let offers = 0;
                let bookedFFE = 0.0;
                let revenue = 0.0;
                let adjFFEPerOffer = 0.0;

                if (!isOpen) {
                    rejNotOpen = searches;
                } else if (remainingCapacity <= 0.0) {
                    rejSoldOut = searches;
                } else {
                    // Make offers & book
                    offers = Math.round(SIMULATOR_CONFIG.offersPerSearch * searches);
                    adjFFEPerOffer = bookingConversion * Math.pow(pricingRatio, -elasticity);
                    const expectedFFE = offers * Math.max(adjFFEPerOffer, 0.0);
                    bookedFFE = Math.min(expectedFFE, remainingCapacity);
                    revenue = (mp * pricingRatio) * bookedFFE;
                }

                // Update cumulative BEFORE considering cancellations
                const cumFFEPreCxl = cumFFE + bookedFFE;
                const cumRevPreCxl = cumRev + revenue;

                // Simplified cancellation logic for turn-based simulation
                let cxlFFE = 0.0;
                let cxlRev = 0.0;
                let cancellationValue = 0.0;

                if (dtd >= noCancelInside && cumFFEPreCxl > 0) {
                    const bookedPrice = cumRevPreCxl / Math.max(cumFFEPreCxl, 1e-9);
                    const refPrice = Math.min(mp, cpRaw);
                    cancellationValue = bookedPrice - refPrice - cancellationFee;

                    if (cancellationValue > 0) {
                        const scale = Math.max(cancellationFee, 1e-9);
                        const baseRate = 1.0 - Math.exp(-cancellationValue / scale);
                        const cxlRate = Math.min(cancelCap, baseRate * cancelCap);
                        
                        cxlFFE = Math.min(cumFFEPreCxl * cxlRate, cumFFEPreCxl);
                        cxlRev = cxlFFE * cancellationFee;
                    }
                }

                // Apply cancellations
                const cancelledBookingRevenue = cxlFFE > 0 ? (cxlFFE / Math.max(cumFFEPreCxl, 1e-9)) * cumRevPreCxl : 0;
                cumFFE = cumFFEPreCxl - cxlFFE;
                cumRev = (cumRevPreCxl - cancelledBookingRevenue) + cxlRev;
                cumCxlFFE += cxlFFE;
                cumCxlRev += cxlRev;

                records.push({
                    date: new Date(currentDate),
                    daysToDepature: dtd,
                    dow: dow,
                    isWeekend: isWeekend,
                    isOpen: isOpen,
                    marketPrice: mp,
                    channelPriceRaw: cpRaw,
                    channelPriceEff: cpEff,
                    pricingRatio: pricingRatio,
                    weekdayMeanSearches: weekdayMean,
                    dowMultiplier: dowMult,
                    searches: searches,
                    offers: offers,
                    baseFFEPerOffer: bookingConversion,
                    adjFFEPerOffer: adjFFEPerOffer,
                    bookedFFE: bookedFFE,
                    revenueBookings: revenue,
                    cancellationsFFE: cxlFFE,
                    cancellationValue: cancellationValue,
                    revenueCancellations: cxlRev,
                    cumulativeFFE: cumFFE,
                    cumulativeRevenue: cumRev,
                    cumulativeCancellationsFFE: cumCxlFFE,
                    cumulativeCancellationsRevenue: cumCxlRev,
                    remainingCapacityEnd: Math.max(capacity - cumFFE, 0.0),
                    offerRejectionsNotOpen: rejNotOpen,
                    offerRejectionsSoldOut: rejSoldOut
                });
            }

            return records;
        }

        function openVessel() {
            if (TURN_STATE.vesselOpened) {
                alert('Vessel is already open!');
                return;
            }

            TURN_STATE.vesselOpened = true;
            TURN_STATE.vesselOpenedOnTurn = TURN_STATE.currentTurn;

            // Update UI
            document.getElementById('openVesselBtn').textContent = '‚úÖ Vessel Opened';
            document.getElementById('openVesselBtn').disabled = true;
            document.getElementById('openVesselBtn').style.background = 'var(--mds-bg-strong)';
            document.getElementById('openVesselBtn').style.cursor = 'not-allowed';
            document.getElementById('openingHelp').textContent = `Opened on Turn ${TURN_STATE.currentTurn}`;
            document.getElementById('vesselStatus').innerHTML = 'üîì Open';
            document.getElementById('vesselStatus').style.color = 'var(--maersk-success)';
        }

        function resetSimulation() {
            // Reset turn state
            TURN_STATE.currentTurn = 1;
            TURN_STATE.vesselOpened = false;
            TURN_STATE.vesselOpenedOnTurn = null;
            TURN_STATE.simulationData = [];
            TURN_STATE.cumulativeFFE = 0;
            TURN_STATE.cumulativeRevenue = 0;
            TURN_STATE.cumulativeCancellations = 0;
            TURN_STATE.turnHistory = [];
            TURN_STATE.currentMarketPrice = getParameterValue('marketPrice'); // Reset to base market price
            TURN_STATE.randomSeed = Math.floor(Math.random() * 10000); // New random seed

            // Reset UI
            updateTurnUI();
            
            // Reset vessel opening button
            document.getElementById('openVesselBtn').textContent = 'üîì Open Vessel for Booking';
            document.getElementById('openVesselBtn').disabled = false;
            document.getElementById('openVesselBtn').style.background = 'var(--maersk-success)';
            document.getElementById('openVesselBtn').style.cursor = 'pointer';
            document.getElementById('openingHelp').textContent = 'One-time decision - cannot close after opening';
            document.getElementById('vesselStatus').innerHTML = 'üîí Closed';
            document.getElementById('vesselStatus').style.color = 'var(--mds-text-secondary)';

            // Reset simulate button
            document.getElementById('simulateTurnBtn').textContent = 'üéØ Simulate Turn';
            document.getElementById('simulateTurnBtn').disabled = false;
            document.getElementById('simulateTurnBtn').style.background = 'var(--maersk-blue)';

            // Clear charts
            if (window.chartInstance) {
                window.chartInstance.data.datasets.forEach(dataset => {
                    dataset.data = [];
                });
                window.chartInstance.update();
            }

            // Clear mini charts
            [window.searchesChart, window.pricingChart, window.capacityChart, window.conversionChart, window.cancellationChart].forEach(chart => {
                if (chart) {
                    chart.data.datasets.forEach(dataset => {
                        dataset.data = [];
                    });
                    chart.update();
                }
            });

            // Reset metrics
            document.getElementById('finalBooking').textContent = '0 FFE';
            document.getElementById('capacityUtilization').textContent = '0% Capacity Utilized';
            document.getElementById('totalRevenue').textContent = '$0';
            document.getElementById('avgPricingRatio').textContent = '1.00x';
            document.getElementById('revenuePerFFE').textContent = '$0';
        }

        function updateTurnUI() {
            document.getElementById('currentTurn').textContent = TURN_STATE.currentTurn;
            
            if (TURN_STATE.currentTurn <= TURN_STATE.maxTurns) {
                const startDTD = SIMULATOR_CONFIG.horizonDays - ((TURN_STATE.currentTurn - 1) * TURN_STATE.daysPerTurn);
                const endDTD = Math.max(0, startDTD - TURN_STATE.daysPerTurn + 1);
                document.getElementById('daysRemaining').textContent = `${startDTD}-${endDTD}`;
            } else {
                document.getElementById('daysRemaining').textContent = 'Complete';
            }
        }

        function updateChartsWithTurnData() {
            if (TURN_STATE.simulationData.length === 0) return;

            // Update main chart
            updateChannelMarkupDisplay();
            
            const labels = TURN_STATE.simulationData.map(d => d.daysToDepature);
            const cumulativeFFE = TURN_STATE.simulationData.map(d => d.cumulativeFFE);
            
            // Calculate cumulative searches
            let cumulativeSearches = 0;
            const cumulativeSearchesData = TURN_STATE.simulationData.map(d => {
                cumulativeSearches += d.searches;
                return cumulativeSearches;
            });
            
            const capacity = TURN_STATE.simulationData.map(d => getParameterValue('capacity'));

            // Update main chart with forecast
            if (window.chartInstance) {
                const forecast = generateForecast();
                
                if (forecast) {
                    // Combine actual and forecast data
                    const allLabels = [...labels, ...forecast.labels.filter(l => !labels.includes(l))].sort((a, b) => b - a);
                    
                    // Extend actual data with nulls for forecast period
                    const extendedActualFFE = allLabels.map(dtd => {
                        const actualIndex = labels.indexOf(dtd);
                        return actualIndex >= 0 ? cumulativeFFE[actualIndex] : null;
                    });
                    
                    const extendedActualSearches = allLabels.map(dtd => {
                        const actualIndex = labels.indexOf(dtd);
                        return actualIndex >= 0 ? cumulativeSearchesData[actualIndex] : null;
                    });
                    
                    // Forecast data (null for actual period)
                    const forecastMostLikely = allLabels.map(dtd => {
                        const forecastIndex = forecast.labels.indexOf(dtd);
                        return forecastIndex >= 0 && !labels.includes(dtd) ? forecast.mostLikely[forecastIndex] : null;
                    });
                    
                    const forecastOptimistic = allLabels.map(dtd => {
                        const forecastIndex = forecast.labels.indexOf(dtd);
                        return forecastIndex >= 0 && !labels.includes(dtd) ? forecast.optimistic[forecastIndex] : null;
                    });
                    
                    const forecastPessimistic = allLabels.map(dtd => {
                        const forecastIndex = forecast.labels.indexOf(dtd);
                        return forecastIndex >= 0 && !labels.includes(dtd) ? forecast.pessimistic[forecastIndex] : null;
                    });
                    
                    const extendedCapacity = allLabels.map(() => getParameterValue('capacity'));
                    
                    window.chartInstance.data.labels = allLabels;
                    window.chartInstance.data.datasets[0].data = extendedActualFFE;
                    window.chartInstance.data.datasets[1].data = extendedActualSearches;
                    window.chartInstance.data.datasets[2].data = extendedCapacity;
                    window.chartInstance.data.datasets[3].data = forecastPessimistic;
                    window.chartInstance.data.datasets[4].data = forecastOptimistic;
                    window.chartInstance.data.datasets[5].data = forecastMostLikely;
                } else {
                    // No forecast available - just show actual data
                    window.chartInstance.data.labels = labels;
                    window.chartInstance.data.datasets[0].data = cumulativeFFE;
                    window.chartInstance.data.datasets[1].data = cumulativeSearchesData;
                    window.chartInstance.data.datasets[2].data = capacity;
                    window.chartInstance.data.datasets[3].data = [];
                    window.chartInstance.data.datasets[4].data = [];
                    window.chartInstance.data.datasets[5].data = [];
                }
                
                window.chartInstance.update();
            }

            // Update mini-charts
            updateMiniCharts(TURN_STATE.simulationData);

            // Update metrics panel
            updateMetricsPanel(TURN_STATE.simulationData);

            // Update insights
            updateEducationalInsights(TURN_STATE.simulationData);

            // Update forecast for next turn
            updateForecast();
        }

        // Generate forecast for remaining turns
        function generateForecast() {
            // Get current parameters
            const capacity = getParameterValue('capacity');
            const marketPrice = TURN_STATE.currentMarketPrice || getParameterValue('marketPrice');
            const channelPrice = getParameterValue('channelPrice');
            const elasticity = getCurrentElasticity();
            const bookingConversion = getParameterValue('bookingConversion');
            const baseWeekdayVolume = getParameterValue('baseWeekdayVolume');
            const rampStart = getParameterValue('rampStart');
            const taperStart = getParameterValue('taperStart');
            const weekendMultiplier = getParameterValue('weekendMultiplier');
            const cancellationFee = getParameterValue('cancellationFee');
            const feePassThrough = getParameterValue('feePassThrough') / 100;
            const cancelCap = getParameterValue('cancelCap') / 100;
            const noCancelInside = getParameterValue('noCancelInside');
            const expectedOpenDTD = getParameterValue('expectedOpenDTD');

            // Calculate starting point for forecast
            const currentDTD = SIMULATOR_CONFIG.horizonDays - ((TURN_STATE.currentTurn - 1) * TURN_STATE.daysPerTurn);
            
            // Generate baseline forecast from current turn forward
            const forecastData = [];
            let cumFFE = TURN_STATE.cumulativeFFE;
            let cumRev = TURN_STATE.cumulativeRevenue;
            let cumCxlFFE = TURN_STATE.cumulativeCancellations;

            console.log('DEBUG generateForecast start:', {
                currentTurn: TURN_STATE.currentTurn,
                currentDTD,
                startingCumFFE: cumFFE,
                vesselOpened: TURN_STATE.vesselOpened
            });

            for (let dtd = currentDTD; dtd >= 0; dtd--) {
                const currentDate = new Date(new Date(SIMULATOR_CONFIG.departureDate).getTime() - dtd * 24 * 60 * 60 * 1000);
                const dow = currentDate.getDay();
                const isWeekend = dow === 0 || dow === 6;
                const dowMult = isWeekend ? weekendMultiplier : 1.0;

                // Use current vessel state OR expected opening for forecast
                const isOpen = TURN_STATE.vesselOpened || (dtd <= expectedOpenDTD);

                // Pricing
                const mp = marketPrice;
                const cpRaw = channelPrice;
                const cpEff = cpRaw + (feePassThrough * cancellationFee);
                const pricingRatio = cpEff / mp;

                // Demand
                const weekdayMean = dtdBellCurve(dtd, baseWeekdayVolume, 0.18, 0.35, rampStart, taperStart);
                const meanSearches = Math.max(0.0, weekdayMean * dowMult);
                const searches = Math.round(meanSearches);

                // Capacity
                const remainingCapacity = Math.max(capacity - cumFFE, 0.0);

                let bookedFFE = 0.0;
                let revenue = 0.0;

                if (isOpen && remainingCapacity > 0.0) {
                    const offers = Math.round(SIMULATOR_CONFIG.offersPerSearch * searches);
                    const adjFFEPerOffer = bookingConversion * Math.pow(pricingRatio, -elasticity);
                    const expectedFFE = offers * Math.max(adjFFEPerOffer, 0.0);
                    bookedFFE = Math.min(expectedFFE, remainingCapacity);
                    revenue = (mp * pricingRatio) * bookedFFE;
                }

                // Simplified cancellation
                const cumFFEPreCxl = cumFFE + bookedFFE;
                let cxlFFE = 0.0;
                if (dtd >= noCancelInside && cumFFEPreCxl > 0) {
                    const bookedPrice = (cumRev + revenue) / Math.max(cumFFEPreCxl, 1e-9);
                    const refPrice = Math.min(mp, cpRaw);
                    const cancellationValue = bookedPrice - refPrice - cancellationFee;
                    if (cancellationValue > 0) {
                        const scale = Math.max(cancellationFee, 1e-9);
                        const baseRate = 1.0 - Math.exp(-cancellationValue / scale);
                        const cxlRate = Math.min(cancelCap, baseRate * cancelCap);
                        cxlFFE = Math.min(cumFFEPreCxl * cxlRate, cumFFEPreCxl);
                    }
                }

                cumFFE = cumFFEPreCxl - cxlFFE;
                cumRev += revenue + (cxlFFE * cancellationFee);
                cumCxlFFE += cxlFFE;

                forecastData.push({
                    dtd: dtd,
                    cumulativeFFE: cumFFE,
                    searches: searches,
                    bookedFFE: bookedFFE
                });
            }

            // Generate uncertainty bands
            const baseVariance = 0.05; // 5% base uncertainty
            const varianceGrowth = 0.02; // 2% additional per turn ahead
            
            const optimisticData = [];
            const pessimisticData = [];
            
            forecastData.forEach((point, index) => {
                const turnsAhead = Math.floor((currentDTD - point.dtd) / TURN_STATE.daysPerTurn) + 1;
                const uncertaintyFactor = baseVariance + varianceGrowth * turnsAhead;
                
                const optimisticValue = Math.min(capacity, point.cumulativeFFE * (1 + uncertaintyFactor));
                const pessimisticValue = Math.max(0, point.cumulativeFFE * (1 - uncertaintyFactor));
                
                optimisticData.push(optimisticValue);
                pessimisticData.push(pessimisticValue);
            });

            const result = {
                labels: forecastData.map(d => d.dtd),
                mostLikely: forecastData.map(d => d.cumulativeFFE),
                optimistic: optimisticData,
                pessimistic: pessimisticData,
                finalForecast: {
                    mostLikely: forecastData[forecastData.length - 1]?.cumulativeFFE || 0,
                    optimistic: optimisticData[optimisticData.length - 1] || 0,
                    pessimistic: pessimisticData[pessimisticData.length - 1] || 0
                }
            };
            
            console.log('DEBUG generateForecast result:', {
                forecastDataLength: forecastData.length,
                finalForecast: result.finalForecast,
                currentTurn: TURN_STATE.currentTurn,
                cumulativeFFE: TURN_STATE.cumulativeFFE
            });
            
            return result;
        }

        // Update forecast display
        function updateForecast() {
            const forecast = generateForecast();
            if (!forecast) {
                console.log('DEBUG: No forecast generated');
                return;
            }

            console.log('DEBUG updateForecast called with:', forecast.finalForecast);

            // Update forecast metrics in the summary bar with the EXACT same values
            const capacityValue = getParameterValue('capacity');
            const mostLikely = Math.round(forecast.finalForecast.mostLikely);
            const optimistic = Math.round(forecast.finalForecast.optimistic);
            const pessimistic = Math.round(forecast.finalForecast.pessimistic);
            
            console.log('DEBUG setting panel values:', { mostLikely, optimistic, pessimistic });
            
            // Check which elements exist
            const projectedFinalEl = document.getElementById('projectedFinal');
            const projectedRangeEl = document.getElementById('projectedRange');
            const capacityUtilForecastEl = document.getElementById('capacityUtilForecast');
            
            console.log('DEBUG element check:', {
                projectedFinalEl: !!projectedFinalEl,
                projectedRangeEl: !!projectedRangeEl,
                capacityUtilForecastEl: !!capacityUtilForecastEl
            });
            
            if (projectedFinalEl) projectedFinalEl.textContent = `${mostLikely} FFE`;
            if (projectedRangeEl) projectedRangeEl.textContent = `${pessimistic} to ${optimistic} FFE`;
            if (capacityUtilForecastEl) capacityUtilForecastEl.textContent = `${Math.round((mostLikely / capacityValue) * 100)}%`;
            
            // Update detailed forecast panel with fresh forecast data
            updateForecastPanel(forecast);
        }

        // Update detailed forecast panel with guardrails and recommendations
        function updateForecastPanel(forecast) {
            const capacity = getParameterValue('capacity');
            const targetValue = capacity; // Use capacity as target for now
            const thresholdBuffer = getParameterValue('guardrailBuffer'); // User-configurable buffer
            
            // Calculate thresholds
            const upperThreshold = Math.round(targetValue * (1 + thresholdBuffer / 100));
            const lowerThreshold = Math.round(targetValue * (1 - thresholdBuffer / 100));
            
            // Use the EXACT same values from the forecast
            const finalMostLikely = forecast.finalForecast?.mostLikely || 0;
            const finalOptimistic = forecast.finalForecast?.optimistic || 0;
            const finalPessimistic = forecast.finalForecast?.pessimistic || 0;
            
            console.log('DEBUG forecast panel using values:', {
                finalMostLikely,
                finalOptimistic, 
                finalPessimistic,
                targetValue,
                upperThreshold,
                lowerThreshold
            });
            
            // Update forecast display with the EXACT same calculations as summary bar
            const forecastRangeEl = document.getElementById('forecastRange');
            const mostLikelyForecastEl = document.getElementById('mostLikelyForecast');
            const targetValueDisplayEl = document.getElementById('targetValueDisplay');
            const targetGapEl = document.getElementById('targetGap');
            
            if (forecastRangeEl) {
                forecastRangeEl.textContent = `${Math.round(finalPessimistic)} - ${Math.round(finalOptimistic)} FFE`;
            }
            if (mostLikelyForecastEl) {
                mostLikelyForecastEl.textContent = `Most Likely: ${Math.round(finalMostLikely)}`;
            }
            
            // Update target comparison
            if (targetValueDisplayEl) {
                targetValueDisplayEl.textContent = `${targetValue} FFE`;
            }
            if (targetGapEl) {
                const gap = finalMostLikely - targetValue;
                const gapSign = gap >= 0 ? '+' : '';
                const gapColor = gap >= 0 ? 'var(--maersk-success)' : 'var(--maersk-error)';
                targetGapEl.textContent = `${gapSign}${Math.round(gap)} FFE`;
                targetGapEl.style.color = gapColor;
            }
            
            // Update guardrail status with safety checks
            const thresholdRangeDisplayEl = document.getElementById('thresholdRangeDisplay');
            if (thresholdRangeDisplayEl) {
                thresholdRangeDisplayEl.textContent = `${lowerThreshold} - ${upperThreshold} FFE`;
            }
            
            const guardrailStatusPanel = document.getElementById('guardrailStatusPanel');
            const quickRecommendation = document.getElementById('quickRecommendation');
            const priceChangeRecommendation = document.getElementById('priceChangeRecommendation');
            const actionButtons = document.getElementById('actionButtons');
            
            if (forecast.finalForecast.mostLikely > upperThreshold) {
                const deviation = ((forecast.finalForecast.mostLikely - upperThreshold) / upperThreshold * 100).toFixed(1);
                if (guardrailStatusPanel) {
                    guardrailStatusPanel.innerHTML = `<span style="color: var(--maersk-error); font-size: 1rem; font-weight: 600;">üî¥ Above (+${deviation}%)</span>`;
                }
                
                if (quickRecommendation) {
                    quickRecommendation.textContent = 'Forecast above target';
                    quickRecommendation.style.color = 'var(--maersk-warning)';
                }
                
                const recommendedPrice = calculateRecommendedChannelPrice(targetValue, 'decrease');
                const recommendedChannelPriceEl = document.getElementById('recommendedChannelPrice');
                const changeRationaleEl = document.getElementById('changeRationale');
                
                if (recommendedChannelPriceEl) recommendedChannelPriceEl.textContent = `$${recommendedPrice}`;
                if (changeRationaleEl) changeRationaleEl.textContent = `Increase price to reduce demand`;
                if (priceChangeRecommendation) priceChangeRecommendation.style.display = 'block';
                if (actionButtons) actionButtons.style.display = 'flex';
                
            } else if (forecast.finalForecast.mostLikely < lowerThreshold) {
                const deviation = ((lowerThreshold - forecast.finalForecast.mostLikely) / lowerThreshold * 100).toFixed(1);
                if (guardrailStatusPanel) {
                    guardrailStatusPanel.innerHTML = `<span style="color: var(--maersk-warning); font-size: 1rem; font-weight: 600;">üü† Below (-${deviation}%)</span>`;
                }
                
                if (quickRecommendation) {
                    quickRecommendation.textContent = 'Forecast below target';
                    quickRecommendation.style.color = 'var(--maersk-warning)';
                }
                
                const recommendedPrice = calculateRecommendedChannelPrice(targetValue, 'increase');
                const recommendedChannelPriceEl = document.getElementById('recommendedChannelPrice');
                const changeRationaleEl = document.getElementById('changeRationale');
                
                if (recommendedChannelPriceEl) recommendedChannelPriceEl.textContent = `$${recommendedPrice}`;
                if (changeRationaleEl) changeRationaleEl.textContent = `Reduce price to stimulate demand`;
                if (priceChangeRecommendation) priceChangeRecommendation.style.display = 'block';
                if (actionButtons) actionButtons.style.display = 'flex';
                
            } else {
                if (guardrailStatusPanel) {
                    guardrailStatusPanel.innerHTML = `<span style="color: var(--maersk-success); font-size: 1rem; font-weight: 600;">‚úÖ Within Range</span>`;
                }
                
                if (quickRecommendation) {
                    quickRecommendation.textContent = 'Forecast on target';
                    quickRecommendation.style.color = 'var(--maersk-success)';
                }
                
                if (priceChangeRecommendation) priceChangeRecommendation.style.display = 'none';
                if (actionButtons) actionButtons.style.display = 'none';
            }
        }

        // Calculate recommended channel price to reach target
        function calculateRecommendedChannelPrice(targetValue, direction) {
            const currentChannelPrice = getParameterValue('channelPrice');
            const marketPrice = TURN_STATE.currentMarketPrice || getParameterValue('marketPrice');
            const elasticity = getCurrentElasticity();
            
            // Simple price adjustment based on gap and elasticity
            const forecast = generateForecast();
            if (!forecast || !forecast.finalForecast) return currentChannelPrice;
            
            const currentForecast = forecast.finalForecast.mostLikely || 0;
            if (currentForecast <= 0) return currentChannelPrice;
            
            const gap = targetValue - currentForecast;
            const gapPercentage = gap / Math.max(currentForecast, 1); // Prevent division by zero
            
            // Limit gap percentage to reasonable bounds
            const boundedGapPercentage = Math.max(-0.5, Math.min(0.5, gapPercentage));
            
            // Use elasticity to estimate required price change (with safety bounds)
            const elasticityFactor = Math.max(0.1, Math.min(5.0, elasticity)); // Bound elasticity
            const requiredPriceChange = Math.pow(1 + boundedGapPercentage, 1 / elasticityFactor) - 1;
            
            // Apply price change with reasonable bounds
            const boundedPriceChange = Math.max(-0.3, Math.min(0.3, requiredPriceChange)); // Max ¬±30%
            const adjustedChannelPrice = currentChannelPrice * (1 + boundedPriceChange);
            
            // Ensure result is reasonable
            const minPrice = marketPrice * 0.7; // At least 70% of market price
            const maxPrice = marketPrice * 2.0; // At most 200% of market price
            const finalPrice = Math.max(minPrice, Math.min(maxPrice, adjustedChannelPrice));
            
            console.log('DEBUG price recommendation:', {
                currentChannelPrice,
                marketPrice,
                gap,
                gapPercentage: boundedGapPercentage,
                requiredPriceChange: boundedPriceChange,
                finalPrice: Math.round(finalPrice)
            });
            
            return Math.round(finalPrice);
        }

        // Apply recommended channel price
        function applyRecommendedChannelPrice() {
            const recommendedPrice = document.getElementById('recommendedChannelPrice').textContent.replace('$', '');
            document.getElementById('channelPrice').value = recommendedPrice;
            updateChannelMarkupDisplay();
            updateChartsWithTurnData();
            
            // Show confirmation
            const applyButton = document.getElementById('applyRecommendation');
            const originalText = applyButton.textContent;
            applyButton.textContent = '‚úì Applied';
            applyButton.style.background = 'var(--maersk-success)';
            
            setTimeout(() => {
                applyButton.textContent = originalText;
                applyButton.style.background = 'var(--maersk-light-blue)';
            }, 2000);
        }

        // DTD Bell Curve - JavaScript implementation of your Python function
        function dtdBellCurve(dtd, baseWeekdayVolume = 1000, kRamp = 0.20, kTaper = 0.35, rampStart = 28, taperStart = 5) {
            const D = Math.max(parseInt(dtd), 0);
            const s1 = 1.0 / (1.0 + Math.exp(-kRamp * (rampStart - D)));   // ramps UP after ~28
            const s2 = 1.0 / (1.0 + Math.exp(-kTaper * (D - taperStart))); // tapers DOWN inside ~5
            return baseWeekdayVolume * s1 * s2;
        }

        // Main simulation function - JavaScript implementation of your Python simulator
        function simulateDeparture() {
            // Get parameters from UI
            const capacity = getParameterValue('capacity');
            const marketPrice = getParameterValue('marketPrice');
            const channelPrice = getParameterValue('channelPrice');
            const elasticity = getCurrentElasticity();
            const bookingConversion = getParameterValue('bookingConversion');
            const baseWeekdayVolume = getParameterValue('baseWeekdayVolume');
            const rampStart = getParameterValue('rampStart');
            const taperStart = getParameterValue('taperStart');
            const weekendMultiplier = getParameterValue('weekendMultiplier');
            const cancellationFee = getParameterValue('cancellationFee');
            const feePassThrough = getParameterValue('feePassThrough') / 100;
            const cancelCap = getParameterValue('cancelCap') / 100;
            const noCancelInside = getParameterValue('noCancelInside');
            const openWeeksBefore = getParameterValue('openWeeksBefore');

            // Generate date range (49 days to departure)
            const departureDate = new Date(SIMULATOR_CONFIG.departureDate);
            const startDate = new Date(departureDate);
            startDate.setDate(startDate.getDate() - SIMULATOR_CONFIG.horizonDays);
            
            const records = [];
            let cumFFE = 0.0;
            let cumRev = 0.0;
            let cumCxlFFE = 0.0;
            let cumCxlRev = 0.0;

            // Opening policy check
            const openingDate = new Date(departureDate);
            openingDate.setDate(openingDate.getDate() - (openWeeksBefore * 7));

            for (let i = 0; i <= SIMULATOR_CONFIG.horizonDays; i++) {
                const currentDate = new Date(startDate);
                currentDate.setDate(currentDate.getDate() + i);
                
                const dtd = Math.floor((departureDate - currentDate) / (1000 * 60 * 60 * 24));
                const dow = currentDate.getDay(); // 0 = Sunday, 6 = Saturday
                const isWeekend = dow === 0 || dow === 6;
                const dowMult = isWeekend ? weekendMultiplier : 1.0;

                // Opening state
                const isOpen = currentDate >= openingDate;

                // Prices + cancellation fee pass-through
                const mp = marketPrice;
                const cpRaw = channelPrice;
                const cpEff = cpRaw + (feePassThrough * cancellationFee);
                const pricingRatio = cpEff / mp;

                // Demand -> searches
                const weekdayMean = dtdBellCurve(dtd, baseWeekdayVolume, 0.18, 0.35, rampStart, taperStart);
                const meanSearches = Math.max(0.0, weekdayMean * dowMult);
                const searches = Math.round(meanSearches);

                // Capacity at start of day
                const remainingCapacity = Math.max(capacity - cumFFE, 0.0);

                let rejNotOpen = 0, rejSoldOut = 0;
                let offers = 0;
                let bookedFFE = 0.0;
                let revenue = 0.0;
                let adjFFEPerOffer = 0.0;

                if (!isOpen) {
                    rejNotOpen = searches;
                } else if (remainingCapacity <= 0.0) {
                    rejSoldOut = searches;
                } else {
                    // Make offers & book
                    offers = Math.round(SIMULATOR_CONFIG.offersPerSearch * searches);
                    adjFFEPerOffer = bookingConversion * Math.pow(pricingRatio, -elasticity);
                    const expectedFFE = offers * Math.max(adjFFEPerOffer, 0.0);
                    bookedFFE = Math.min(expectedFFE, remainingCapacity);
                    revenue = (mp * pricingRatio) * bookedFFE;
                }

                // Update cumulative BEFORE considering cancellations
                const cumFFEPreCxl = cumFFE + bookedFFE;
                const cumRevPreCxl = cumRev + revenue;

                // Cancellations
                let cxlFFE = 0.0;
                let cxlRev = 0.0;
                let cancellationValue = 0.0;

                if (dtd >= noCancelInside && cumFFEPreCxl > 0) {
                    const bookedPrice = cumRevPreCxl / Math.max(cumFFEPreCxl, 1e-9);
                    const refPrice = Math.min(mp, cpRaw);
                    cancellationValue = bookedPrice - refPrice - cancellationFee;

                    if (cancellationValue > 0) {
                        const scale = Math.max(cancellationFee, 1e-9);
                        const baseRate = 1.0 - Math.exp(-cancellationValue / scale);
                        const cxlRate = Math.min(cancelCap, baseRate * cancelCap);
                        
                        cxlFFE = Math.min(cumFFEPreCxl * cxlRate, cumFFEPreCxl);
                        cxlRev = cxlFFE * cancellationFee;
                    }
                }

                // Apply cancellations to cumulative state
                cumFFE = cumFFEPreCxl - cxlFFE;
                // Revenue calculation: keep booking revenue, add cancellation fee revenue
                // Don't double-count the original booking revenue for cancelled FFE
                const cancelledBookingRevenue = cxlFFE > 0 ? (cxlFFE / Math.max(cumFFEPreCxl, 1e-9)) * cumRevPreCxl : 0;
                cumRev = (cumRevPreCxl - cancelledBookingRevenue) + cxlRev;
                cumCxlFFE += cxlFFE;
                cumCxlRev += cxlRev;

                records.push({
                    date: new Date(currentDate),
                    daysToDepature: dtd,
                    dow: dow,
                    isWeekend: isWeekend,
                    isOpen: isOpen,
                    marketPrice: mp,
                    channelPriceRaw: cpRaw,
                    channelPriceEff: cpEff,
                    pricingRatio: pricingRatio,
                    weekdayMeanSearches: weekdayMean,
                    dowMultiplier: dowMult,
                    searches: searches,
                    offers: offers,
                    baseFFEPerOffer: bookingConversion,
                    adjFFEPerOffer: adjFFEPerOffer,
                    bookedFFE: bookedFFE,
                    revenueBookings: revenue,
                    cancellationsFFE: cxlFFE,
                    cancellationValue: cancellationValue,
                    revenueCancellations: cxlRev,
                    cumulativeFFE: cumFFE,
                    cumulativeRevenue: cumRev,
                    cumulativeCancellationsFFE: cumCxlFFE,
                    cumulativeCancellationsRevenue: cumCxlRev,
                    remainingCapacityEnd: Math.max(capacity - cumFFE, 0.0),
                    offerRejectionsNotOpen: rejNotOpen,
                    offerRejectionsSoldOut: rejSoldOut
                });
            }

            return records;
        }

        // Chart initialization and update
        function initChart() {
            const ctx = document.getElementById('bookingChart');
            if (!ctx) return;

            if (window.chartInstance) {
                window.chartInstance.destroy();
            }

            window.chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Cumulative FFE Booked',
                            data: [],
                            borderColor: 'rgb(66, 176, 213)',
                            backgroundColor: 'rgba(66, 176, 213, 0.1)',
                            borderWidth: 3,
                            pointRadius: 4,
                            pointBackgroundColor: 'rgb(66, 176, 213)',
                            fill: true,
                            tension: 0.3
                        },
                        {
                            label: 'Cumulative Searches',
                            data: [],
                            borderColor: 'rgba(138, 138, 138, 0.7)',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 2,
                            fill: false,
                            tension: 0.3,
                            borderDash: [5, 5],
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Capacity',
                            data: [],
                            borderColor: 'rgb(229, 62, 62)',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false,
                            tension: 0,
                            borderDash: [10, 5]
                        },
                        {
                            label: 'Forecast - Pessimistic',
                            data: [],
                            borderColor: 'rgba(229, 62, 62, 0.5)',
                            backgroundColor: 'rgba(229, 62, 62, 0.1)',
                            borderWidth: 1,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.3,
                            borderDash: [3, 3]
                        },
                        {
                            label: 'Forecast - Optimistic',
                            data: [],
                            borderColor: 'rgba(0, 170, 136, 0.5)',
                            backgroundColor: 'rgba(0, 170, 136, 0.1)',
                            borderWidth: 1,
                            pointRadius: 0,
                            fill: '-1',
                            tension: 0.3,
                            borderDash: [3, 3]
                        },
                        {
                            label: 'Forecast - Most Likely',
                            data: [],
                            borderColor: 'rgba(66, 176, 213, 0.6)',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 2,
                            fill: false,
                            tension: 0.3,
                            borderDash: [6, 3]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Days to Departure',
                                font: { size: 14, weight: '600' },
                                color: 'rgb(212, 212, 212)'
                            },
                            reverse: false, // 49 DTD on left, 0 DTD on right
                            grid: {
                                color: 'rgba(138, 138, 138, 0.3)'
                            },
                            ticks: {
                                color: 'rgb(138, 138, 138)',
                                font: { size: 12 }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Cumulative FFE',
                                font: { size: 14, weight: '600' },
                                color: 'rgb(212, 212, 212)'
                            },
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(138, 138, 138, 0.3)'
                            },
                            ticks: {
                                color: 'rgb(138, 138, 138)',
                                font: { size: 12 }
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Cumulative Searches',
                                font: { size: 12, weight: '600' },
                                color: 'rgb(180, 180, 180)'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                            ticks: {
                                color: 'rgb(138, 138, 138)',
                                font: { size: 10 }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                color: 'rgb(212, 212, 212)',
                                font: { size: 11, weight: '500' },
                                padding: 12,
                                usePointStyle: true
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(33, 33, 33, 0.95)',
                            titleColor: 'rgb(240, 240, 240)',
                            bodyColor: 'rgb(212, 212, 212)',
                            borderColor: 'rgb(76, 76, 76)',
                            borderWidth: 1,
                            cornerRadius: 8,
                            padding: 12
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }


        // Initialize mini-charts
        function initMiniCharts() {
            // Common chart options for mini-charts
            const miniChartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        display: true,
                        grid: { color: 'rgba(138, 138, 138, 0.2)' },
                        ticks: { 
                            color: 'rgb(138, 138, 138)', 
                            font: { size: 10 },
                            maxTicksLimit: 8
                        }
                    },
                    y: {
                        display: true,
                        beginAtZero: true,
                        grid: { color: 'rgba(138, 138, 138, 0.2)' },
                        ticks: { 
                            color: 'rgb(138, 138, 138)', 
                            font: { size: 10 }
                        }
                    }
                },
                plugins: {
                    legend: { 
                        display: true,
                        position: 'bottom',
                        labels: {
                            color: 'rgb(212, 212, 212)',
                            font: { size: 9 },
                            padding: 8,
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(33, 33, 33, 0.95)',
                        titleColor: 'rgb(240, 240, 240)',
                        bodyColor: 'rgb(212, 212, 212)',
                        borderColor: 'rgb(76, 76, 76)',
                        borderWidth: 1,
                        cornerRadius: 6,
                        padding: 8,
                        titleFont: { size: 11 },
                        bodyFont: { size: 10 }
                    }
                },
                interaction: { intersect: false, mode: 'index' }
            };

            // 1. Searches & Rejections Chart (Cumulative with Stacked Rejection Areas)
            const searchesCtx = document.getElementById('searchesChart');
            if (searchesCtx) {
                window.searchesChart = new Chart(searchesCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Cumulative Rejected (Not Open)',
                                data: [],
                                backgroundColor: 'rgba(255, 165, 0, 0.7)',
                                borderColor: 'rgb(255, 165, 0)',
                                borderWidth: 1,
                                pointRadius: 1,
                                fill: 'origin',
                                tension: 0.3
                            },
                            {
                                label: 'Cumulative Rejected (Sold Out)',
                                data: [],
                                backgroundColor: 'rgba(229, 62, 62, 0.7)',
                                borderColor: 'rgb(229, 62, 62)',
                                borderWidth: 1,
                                pointRadius: 1,
                                fill: '-1',
                                tension: 0.3
                            },
                            {
                                label: 'Cumulative Searches',
                                data: [],
                                backgroundColor: 'transparent',
                                borderColor: 'rgba(138, 138, 138, 0.8)',
                                borderWidth: 2,
                                pointRadius: 2,
                                fill: false,
                                tension: 0.3,
                                borderDash: [4, 4]
                            }
                        ]
                    },
                    options: {
                        ...miniChartOptions,
                        scales: {
                            ...miniChartOptions.scales,
                            y: {
                                ...miniChartOptions.scales.y,
                                title: { display: true, text: 'Cumulative Volume', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            },
                            x: {
                                ...miniChartOptions.scales.x,
                                title: { display: true, text: 'DTD', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            }
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            ...miniChartOptions.plugins,
                            tooltip: {
                                ...miniChartOptions.plugins.tooltip,
                                mode: 'index',
                                intersect: false
                            }
                        }
                    }
                });
            }

            // 2. Market vs Channel Pricing Chart
            const pricingCtx = document.getElementById('pricingChart');
            if (pricingCtx) {
                window.pricingChart = new Chart(pricingCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Market Price',
                                data: [],
                                borderColor: 'rgb(255, 180, 50)',
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                pointRadius: 2,
                                tension: 0.1
                            },
                            {
                                label: 'Channel Price (Raw)',
                                data: [],
                                borderColor: 'rgb(66, 176, 213)',
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                pointRadius: 2,
                                tension: 0.1
                            },
                            {
                                label: 'Channel Price (w/ Fees)',
                                data: [],
                                borderColor: 'rgb(138, 43, 226)',
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                pointRadius: 2,
                                tension: 0.1,
                                borderDash: [4, 4]
                            }
                        ]
                    },
                    options: {
                        ...miniChartOptions,
                        scales: {
                            ...miniChartOptions.scales,
                            y: {
                                ...miniChartOptions.scales.y,
                                beginAtZero: false, // Don't start at zero - focus on actual price range
                                title: { display: true, text: 'Price ($)', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            },
                            x: {
                                ...miniChartOptions.scales.x,
                                title: { display: true, text: 'DTD', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            }
                        }
                    }
                });
            }

            // 3. Remaining Capacity Chart
            const capacityCtx = document.getElementById('capacityChart');
            if (capacityCtx) {
                window.capacityChart = new Chart(capacityCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Remaining Capacity',
                                data: [],
                                borderColor: 'rgb(229, 62, 62)',
                                backgroundColor: 'rgba(229, 62, 62, 0.1)',
                                borderWidth: 2,
                                pointRadius: 2,
                                fill: true,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        ...miniChartOptions,
                        scales: {
                            ...miniChartOptions.scales,
                            y: {
                                ...miniChartOptions.scales.y,
                                title: { display: true, text: 'FFE', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            },
                            x: {
                                ...miniChartOptions.scales.x,
                                title: { display: true, text: 'DTD', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            }
                        }
                    }
                });
            }

            // 4. Booking Conversion Chart
            const conversionCtx = document.getElementById('conversionChart');
            if (conversionCtx) {
                window.conversionChart = new Chart(conversionCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Base Conversion Rate',
                                data: [],
                                borderColor: 'rgba(138, 138, 138, 0.6)',
                                backgroundColor: 'transparent',
                                borderWidth: 1,
                                pointRadius: 1,
                                tension: 0.1,
                                borderDash: [3, 3]
                            },
                            {
                                label: 'Adjusted Conversion Rate',
                                data: [],
                                borderColor: 'rgb(0, 170, 136)',
                                backgroundColor: 'rgba(0, 170, 136, 0.1)',
                                borderWidth: 2,
                                pointRadius: 2,
                                fill: true,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        ...miniChartOptions,
                        scales: {
                            ...miniChartOptions.scales,
                            y: {
                                ...miniChartOptions.scales.y,
                                title: { display: true, text: 'Rate', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            },
                            x: {
                                ...miniChartOptions.scales.x,
                                title: { display: true, text: 'DTD', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            }
                        }
                    }
                });
            }

            // 5. Cancellations & Revenue Chart
            const cancellationCtx = document.getElementById('cancellationChart');
            if (cancellationCtx) {
                window.cancellationChart = new Chart(cancellationCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Cumulative Cancellations (FFE)',
                                data: [],
                                backgroundColor: 'rgba(255, 165, 0, 0.7)',
                                borderColor: 'rgb(255, 165, 0)',
                                borderWidth: 2,
                                pointRadius: 2,
                                fill: true,
                                tension: 0.3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Cumulative Cancellation Revenue ($)',
                                data: [],
                                type: 'line',
                                borderColor: 'rgb(0, 170, 136)',
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                pointRadius: 2,
                                tension: 0.3,
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        ...miniChartOptions,
                        scales: {
                            x: {
                                ...miniChartOptions.scales.x,
                                title: { display: true, text: 'DTD', color: 'rgb(180, 180, 180)', font: { size: 10 } }
                            },
                            y: {
                                ...miniChartOptions.scales.y,
                                title: { display: true, text: 'FFE', color: 'rgb(180, 180, 180)', font: { size: 10 } },
                                position: 'left'
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: { display: true, text: 'Revenue ($)', color: 'rgb(180, 180, 180)', font: { size: 10 } },
                                grid: { drawOnChartArea: false },
                                ticks: { 
                                    color: 'rgb(138, 138, 138)', 
                                    font: { size: 10 }
                                }
                            }
                        }
                    }
                });
            }
        }


        // Update mini-charts with simulation data
        function updateMiniCharts(data) {
            const labels = data.map(d => d.daysToDepature);

            // 1. Update Searches & Rejections Chart (Cumulative)
            if (window.searchesChart) {
                let cumulativeRejectedNotOpen = 0;
                let cumulativeRejectedSoldOut = 0;
                let cumulativeSearches = 0;

                // Calculate cumulative rejections with proper logic
                const cumulativeNotOpenData = [];
                const cumulativeSoldOutData = [];
                const cumulativeSearchesData = [];

                data.forEach(d => {
                    // Always accumulate total searches
                    cumulativeSearches += d.searches;
                    cumulativeSearchesData.push(cumulativeSearches);

                    // Only accumulate rejections that actually happened
                    // (the simulation already has the correct logic)
                    cumulativeRejectedNotOpen += d.offerRejectionsNotOpen;
                    cumulativeRejectedSoldOut += d.offerRejectionsSoldOut;

                    // Store cumulative values for chart
                    cumulativeNotOpenData.push(cumulativeRejectedNotOpen);
                    cumulativeSoldOutData.push(cumulativeRejectedNotOpen + cumulativeRejectedSoldOut);
                });

                window.searchesChart.data.labels = labels;
                window.searchesChart.data.datasets[0].data = cumulativeNotOpenData;
                window.searchesChart.data.datasets[1].data = cumulativeSoldOutData;
                window.searchesChart.data.datasets[2].data = cumulativeSearchesData;
                window.searchesChart.update('none');
            }

            // 2. Update Market vs Channel Pricing Chart
            if (window.pricingChart) {
                const marketPrices = data.map(d => d.marketPrice);
                const channelPricesRaw = data.map(d => d.channelPriceRaw);
                const channelPricesEff = data.map(d => d.channelPriceEff);

                window.pricingChart.data.labels = labels;
                window.pricingChart.data.datasets[0].data = marketPrices;
                window.pricingChart.data.datasets[1].data = channelPricesRaw;
                window.pricingChart.data.datasets[2].data = channelPricesEff;
                window.pricingChart.update('none');
            }

            // 3. Update Remaining Capacity Chart
            if (window.capacityChart) {
                const remainingCapacity = data.map(d => d.remainingCapacityEnd);

                window.capacityChart.data.labels = labels;
                window.capacityChart.data.datasets[0].data = remainingCapacity;
                window.capacityChart.update('none');
            }

            // 4. Update Booking Conversion Chart
            if (window.conversionChart) {
                const baseConversion = data.map(d => d.baseFFEPerOffer);
                const adjustedConversion = data.map(d => d.adjFFEPerOffer);

                window.conversionChart.data.labels = labels;
                window.conversionChart.data.datasets[0].data = baseConversion;
                window.conversionChart.data.datasets[1].data = adjustedConversion;
                window.conversionChart.update('none');
            }

            // 5. Update Cancellations & Revenue Chart
            if (window.cancellationChart) {
                // Calculate cumulative cancellations
                let cumulativeCancellations = 0;
                const cumulativeCancellationsData = data.map(d => {
                    cumulativeCancellations += d.cancellationsFFE;
                    return cumulativeCancellations;
                });

                // Calculate cumulative cancellation revenue
                let cumulativeCancellationRevenue = 0;
                const cumulativeCancellationRevenueData = data.map(d => {
                    cumulativeCancellationRevenue += d.revenueCancellations;
                    return cumulativeCancellationRevenue;
                });

                window.cancellationChart.data.labels = labels;
                window.cancellationChart.data.datasets[0].data = cumulativeCancellationsData;
                window.cancellationChart.data.datasets[1].data = cumulativeCancellationRevenueData;
                window.cancellationChart.update('none');
            }
        }

        // Update metrics panel
        function updateMetricsPanel(data) {
            if (!data || data.length === 0) {
                // Reset to default values if no data
                document.getElementById('finalBooking').textContent = '0 FFE';
                document.getElementById('capacityUtilization').textContent = '0% Capacity Utilized';
                document.getElementById('totalRevenue').textContent = '$0';
                document.getElementById('totalCancellations').textContent = '0 FFE';
                document.getElementById('avgPricingRatio').textContent = '1.00x';
                document.getElementById('revenuePerFFE').textContent = '$0';
                return;
            }
            
            const finalRecord = data[data.length - 1];
            const capacity = getParameterValue('capacity');
            
            // Calculate metrics
            const finalBooking = finalRecord.cumulativeFFE;
            const capacityUtil = (finalBooking / capacity * 100).toFixed(1);
            const totalRevenue = finalRecord.cumulativeRevenue;
            const cancellationRevenue = finalRecord.cumulativeCancellationsRevenue;
            // Calculate booking revenue as total minus cancellation fees
            const bookingRevenue = totalRevenue - cancellationRevenue;
            const totalCancellations = finalRecord.cumulativeCancellationsFFE;
            const cancelRate = ((totalCancellations / Math.max(finalBooking + totalCancellations, 1)) * 100).toFixed(1);
            
            // Calculate average pricing ratio (weighted by bookings)
            let totalWeightedRatio = 0;
            let totalBookings = 0;
            data.forEach(d => {
                if (d.bookedFFE > 0) {
                    totalWeightedRatio += d.pricingRatio * d.bookedFFE;
                    totalBookings += d.bookedFFE;
                }
            });
            const avgPricingRatio = totalBookings > 0 ? (totalWeightedRatio / totalBookings).toFixed(2) : "1.00";
            const revenuePerFFE = finalBooking > 0 ? (totalRevenue / finalBooking).toFixed(0) : "0";

            // Update UI (only elements that exist in compact layout)
            const finalBookingEl = document.getElementById('finalBooking');
            const capacityUtilizationEl = document.getElementById('capacityUtilization');
            const totalRevenueEl = document.getElementById('totalRevenue');
            const totalCancellationsEl = document.getElementById('totalCancellations');
            const avgPricingRatioEl = document.getElementById('avgPricingRatio');
            const revenuePerFFEEl = document.getElementById('revenuePerFFE');
            
            if (finalBookingEl) finalBookingEl.textContent = `${Math.round(finalBooking)} FFE`;
            if (capacityUtilizationEl) capacityUtilizationEl.textContent = `${capacityUtil}% Capacity Utilized`;
            if (totalRevenueEl) totalRevenueEl.textContent = `$${Math.round(totalRevenue).toLocaleString()}`;
            if (totalCancellationsEl) totalCancellationsEl.textContent = `${Math.round(totalCancellations)} FFE`;
            if (avgPricingRatioEl) avgPricingRatioEl.textContent = `${avgPricingRatio}x`;
            if (revenuePerFFEEl) revenuePerFFEEl.textContent = `$${revenuePerFFE}`;
            
            // Update additional elements if they exist (for backwards compatibility)
            const bookingRevenueEl = document.getElementById('bookingRevenue');
            const cancellationRevenueEl = document.getElementById('cancellationRevenue');
            const cancelRateEl = document.getElementById('cancellationRate');
            
            if (bookingRevenueEl) bookingRevenueEl.textContent = `$${Math.round(bookingRevenue).toLocaleString()}`;
            if (cancellationRevenueEl) cancellationRevenueEl.textContent = `$${Math.round(cancellationRevenue).toLocaleString()}`;
            if (cancelRateEl) cancelRateEl.textContent = `${cancelRate}%`;
        }

        // Update educational insights
        function updateEducationalInsights(data) {
            const finalRecord = data[data.length - 1];
            const capacity = getParameterValue('capacity');
            const finalBooking = finalRecord.cumulativeFFE;
            const capacityUtil = (finalBooking / capacity * 100);
            const totalCancellations = finalRecord.cumulativeCancellationsFFE;
            const avgPricingRatio = parseFloat(document.getElementById('avgPricingRatio').textContent.replace('x', ''));

            let insight = "";
            let cardClass = "neutral";

            if (capacityUtil >= 95) {
                insight = "üéØ <strong>Optimal Performance:</strong> Near full capacity utilization with strong demand curve execution. The bell-shaped search pattern and pricing strategy worked effectively.";
                cardClass = "success";
            } else if (capacityUtil >= 70) {
                insight = "üìà <strong>Good Performance:</strong> Solid capacity utilization. Consider adjusting pricing ratio or opening policy to capture remaining demand.";
                cardClass = "neutral";
            } else if (capacityUtil >= 40) {
                insight = "‚ö†Ô∏è <strong>Moderate Performance:</strong> Room for improvement. Try reducing channel markup, extending opening window, or adjusting demand curve parameters.";
                cardClass = "warning";
            } else {
                insight = "üî¥ <strong>Low Performance:</strong> Significant capacity underutilization. Consider major strategy adjustments: lower pricing, earlier opening, or higher base demand.";
                cardClass = "warning";
            }

            if (totalCancellations > finalBooking * 0.1) {
                insight += ` High cancellation rate (${(totalCancellations/(finalBooking + totalCancellations)*100).toFixed(0)}%) suggests pricing misalignment or aggressive cancellation policies.`;
            }

            if (avgPricingRatio > 1.1) {
                insight += ` High pricing ratio (${avgPricingRatio}x) may be limiting demand conversion.`;
            }

            const insightCard = document.getElementById('insightCard');
            insightCard.className = `insight-card ${cardClass}`;
            insightCard.innerHTML = `<h3>üéì Educational Insights</h3><p>${insight}</p>`;
        }

        // UI Controls
        function toggleAdvancedParams() {
            const content = document.getElementById('advancedContent');
            const arrow = document.getElementById('advancedArrow');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(180deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        function resetParameters() {
            Object.keys(SIMULATOR_CONFIG.defaults).forEach(key => {
                const element = document.getElementById(key);
                if (element) {
                    element.value = SIMULATOR_CONFIG.defaults[key];
                }
            });
            runSimulation();
        }

        // Initialize on page load
        window.addEventListener('load', function() {
            initChart();
            initMiniCharts();
            updateTurnUI();
            updateChannelMarkupDisplay();
            updateForecast(); // Show initial forecast
        });

        // Mark todo as complete
        console.log("‚úÖ Advanced simulator implementation complete");
    </script>
</body>
</html>
